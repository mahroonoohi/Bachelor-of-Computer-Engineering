A formal sp e cification of the jq language
MICHAEL F Ã„RBER
A uthorsâ€™ addr esses: Michael FÃ¤rb er , michael.faerb er@ge denkt.at.
This w ork is license d under a Cr eativ e Commons Attribution 4.0 International License .
Â© 2024 Cop yright held by the o wner/author( s).jq is a widely use d to ol that pr o vides a pr ogramming language to manipulate JSON data. Ho w e v er , the jq
language is curr ently only sp e ciï¬e d by its implementation, making it diï¬ƒcult to r eason ab out its b ehaviour .
T o this end, w e pr o vide a formal syntax and denotational semantics for a large subset of the jq language . Our
most signiï¬cant contribution is to pr o vide a ne w way to interpr et up dates that allo ws for mor e pr e dictable
and p erformant e xe cution.
CCS Concepts:  Softwar e and its engine ering  â†’  Semantics ; Functional languages .
A dditional K e y W or ds and P hrases: jq, JSON, semantics
1 INTRODUCTION
UNIX has p opularise d the concept of ï¬lters  and pip es  [1] : A ï¬lter is a pr ogram that r eads fr om an
input str eam and writes to an output str eam. Pip es ar e use d to comp ose ï¬lters.
JSON ( JavaScript Obje ct Notation) is a widely use d data serialisation format [2] . A JSON value
is either null, a b o olean, a numb er , a string, an array of values, or an asso ciativ e map fr om strings
to values.
jq is a to ol that pr o vides a language to deï¬ne ï¬lters and an interpr eter to e xe cute them. Wher e
UNIX ï¬lters op erate on str eams of characters, jq ï¬lters op erate on str eams of JSON values. This
allo ws to manipulate JSON data with r elativ ely compact ï¬lters. For e xample , giv en as input the
public JSON dataset of str e ets in Paris [3] , jq r etrie v es the numb er of str e ets (6528) with the ï¬l-
ter â€œlength â€ , the names of the str e ets with the ï¬lter â€œ .[].nomvoie â€ , and the total length of all
str e ets (1574028 m) with the ï¬lter â€œ [.[].longueur] | add â€ . jq pr o vides syntax to up date data; for
e xample , to r emo v e ge ographical data obtaine d by â€œ .[].geo_shape â€ , but leaving intact all other
data, w e can use â€œ .[].geo_shape |= empty â€ . This shrinks the dataset fr om ~25 MB to ~7 MB.
jq pr o vides a T uring-complete language that is inter esting on its o wn; for e xample , â€œ [0, 1] |
recurse([.[1], add])[0]"  generates the str eam of Fib onacci numb ers. This makes jq a widely
use d to ol. W e r efer to the pr ogram jq as â€œjqâ€ and to its language as â€œthe jq language â€ .
The jq language is a dynamically typ e d, lazily e valuate d functional pr ogramming language with
se cond-class higher-or der functions [4] . The semantics of the jq language ar e only informally
sp e ciï¬e d, for e xample in the jq manual [5] . Ho w e v er , the do cumentation fr e quently do es not
co v er certain cases, and historically , the implementation often contradicte d the do cumentation.
The underlying issue is that ther e e xiste d no formally sp e ciï¬e d semantics to r ely on. Having such
semantics allo ws to determine whether certain b ehaviour of a jq implementation is accidental or
intende d.
Ho w e v er , a formal sp e ciï¬cation of the b ehaviour of jq w ould b e v er y v erb ose , b e cause jq has
many sp e cial cases whose merit is not appar ent. Ther efor e , w e hav e striv en to cr eate denotational
semantics ( Se ctionÂ  5 ) that closely r esemble those of jq such that in most cases, their b ehaviour2 FÃ¤rb er
coincides, wher eas the y may diï¬€er in mor e e xotic cases. The goals for cr eating these semantics
w er e , in descending or der of imp ortance:
â€¢ Simplicity: The semantics should b e easy to describ e , understand, and implement.
â€¢ Performance: The semantics should allo w for p erformant e xe cution.
â€¢ Compatibility: The semantics should b e consistent with jq.
W e cr eate d these semantics e xp erimentally , by coming up with jq ï¬lters and obser ving their out-
put for all kinds of inputs. Fr om this, w e synthesise d mathematical deï¬nitions to mo del the b e-
haviour of jq. The most signiï¬cant impr o v ement o v er jq b ehaviour describ e d in this te xt ar e the
ne w up date semantics ( Se ctionÂ  6 ), which ar e simpler to describ e and implement, eliminate a range
a p otential err ors, and allo w for mor e p erformant e xe cution.
The structur e of this te xt is as follo ws: Se ctionÂ  2  intr o duces jq by a series of e xamples that giv e
a glimpse of actual jq syntax and b ehaviour . Fr om that p oint on, the structur e of the te xt follo ws
the e xe cution of a jq pr ogram as sho wn in Figur eÂ  1 . Se ctionÂ  3  formalises a subset of jq syntax and
sho ws ho w jq syntax can b e transforme d to incr easingly lo w-le v el interme diate r epr esentations
calle d HIR ( Se ctionÂ  3.1 ) and MIR ( Se ctionÂ  3.2 ). After this, the semantics part starts: Se ctionÂ  4  de-
ï¬nes the typ e of JSON values and the elementar y op erations that jq pr o vides for it. Furthermor e ,
it deï¬nes other basic data typ es such as err ors, e xceptions, and str eams. Se ctionÂ  5  sho ws ho w to
e valuate jq ï¬lters on a giv en input value . Se ctionÂ  6  then sho ws ho w to e valuate a class of jq ï¬lters
that up date values using a ï¬lter calle d path  that deï¬nes which parts of the input to up date , and
a ï¬lter that deï¬nes what the values matching the path should b e r eplace d with. The semantics of
jq and those that will b e sho wn in this te xt diï¬€er most notably in the case of up dates. Finally , w e
sho w ho w to pr o v e pr op erties of jq pr ograms by e quational r easoning in Se ctionÂ 7 .
input value
jq pr ogram
output values & err orsHIR MIREvaluationUp date e valuation
V alue op erations
Figur eÂ  1: Evaluation of a jq pr ogram with an input value . Solid lines indicate data ï¬‚o w , wher eas a
dashe d line indicates that a comp onent is deï¬ne d in terms of another .2 T OUR OF JQ
This goal of this se ction is to conv e y an intuition ab out ho w jq functions. The oï¬ƒcial do cumenta-
tion of jq is its user manual [5] .
jq pr ograms ar e calle d ï¬lters . For no w , let us consider a ï¬lter to b e a function fr om a value to
a ( lazy , p ossibly inï¬nite) str eam of values. Furthermor e , in this se ction, let us assume a value to
b e either a b o olean, an integer , or an array of values. (W e intr o duce the full set of JSON values in
Se ctionÂ 4 .)A formal sp e cification of the jq language 3
The identity ï¬lter â€œ . â€ r eturns a str eam containing the input. Â³
Â³ The ï¬lters in this se ction can b e e xe cute d on most UNIX shells by echo $INPUT | jq $FILTER ,
wher e $INPUT  is the input value in JSON format and $FILTER  is the jq pr ogram to b e e xe cute d. Often, it
is conv enient to quote the ï¬lter; for e xample , to run the ï¬lter â€œ . â€ with the input value 0 , w e can run
echo 0 | jq '.' . In case wher e the input value do es not matter , w e can also use jq -n $FILTER ,
which runs the ï¬lter with the input value null . W e use jq 1.7.Arithmetic op erations, such as addition, subtraction, multiplication, division, and r emainder ,
ar e available in jq. For e xample , â€œ . + 1 â€ r eturns a str eam containing the successor of the input.
Her e , â€œ1 â€ is a ï¬lter that r eturns the value 1  for any input.
Concatenation is an imp ortant op erator in jq: The ï¬lter â€œ f, g â€ concatenates the outputs of the
ï¬lters f  and g . For e xample , the ï¬lter â€œ ., . â€ r eturns a str eam containing the input value twice .
Comp osition is one of the most imp ortant op erators in jq: The ï¬lter â€œ f | g â€ maps the ï¬lter g
o v er all outputs of the ï¬lter f . For e xample , â€œ (1, 2, 3) | (. + 1) â€ r eturns 2, 3, 4 .
Arrays ar e cr eate d fr om a str eam pr o duce d by f  using the ï¬lter â€œ [f] â€ . For e xample , the ï¬lter
â€œ[1, 2, 3] â€ concatenates the output of the ï¬lters â€œ 1 â€ , â€œ2 â€ , and â€œ3 â€ and puts it into an array , yielding
the value [1, 2, 3] . The inv erse ï¬lter â€œ .[] â€ r eturns a str eam containing the values of an array
if the input is an array . For e xample , running â€œ .[] â€ on the array [1, 2, 3]  yields the str eam 1,
2, 3  consisting of thr e e values. W e can combine the tw o sho wn ï¬lters to map o v er arrays; for
e xample , when giv en the input [1, 2, 3] , the ï¬lter â€œ [.[] | (. + 1)] â€ r eturns a single value
[2, 3, 4] . The values of an array at indices pr o duce d by f  ar e r eturne d by â€œ .[f] â€ . For e xample ,
giv en the input [1, 2, 3] , the ï¬lter â€œ .[0, 2, 0] â€ r eturns the str eam 1, 3, 1 .
Case distinctions can b e p erforme d with the ï¬lter â€œ if f then g else h end â€ . For e v er y value
v  pr o duce d by f , this ï¬lter r eturns the output of g  if v  is true and the output of h  other wise . For
e xample , giv en the input 1 , the ï¬lter â€œ if (. < 1, . == 1, . >= 1) then . else [] end â€ r eturns
[], 1, 1 .
W e can deï¬ne ï¬lters by using the syntax â€œ def f(x1; ...; xn): g; â€ , which deï¬nes an ï¬l-
ter f  taking n  arguments by g , wher e g  can r efer to x1  to xn . For e xample , jq pr o vides the ï¬lter
â€œrecurse(f) â€ to calculate ï¬x p oints, which could b e deï¬ne d by â€œ def recurse(f): ., (f |
recurse(f)); â€ . Using this, w e can deï¬ne a ï¬lter to calculate the factorial function, for e xample .
Example 2.1  (Factorial) :  Let us deï¬ne a ï¬lter fac  that should r eturn ğ‘› !  for any input numb er ğ‘› .
W e will deï¬ne fac  using the ï¬x p oint of a ï¬lter update . The input and output of update  shall b e
an array [n, acc] , satisfying the invariant that the ï¬nal output is acc  times the factorial of n . The
initial value passe d to update  is the array â€œ [., 1] â€ . W e can r etrie v e n  fr om the array with â€œ .[0]
â€ and acc  with â€œ.[1] â€ . W e can no w deï¬ne update  as â€œif .[0] > 1 then [.[0] - 1, .[0] * .
[1]] else empty end â€ , wher e â€œ empty â€ is a ï¬lter that r eturns an empty str eam. Giv en the input
value 4 , the ï¬lter â€œ [., 1] | recurse(update) â€ r eturns [4, 1], [3, 4], [2, 12], [1, 24] . W e
ar e , ho w e v er , only inter este d in the accumulator containe d in the last value . So w e can write â€œ [.,
1] | last(recurse(update)) | .[ 1] â€ , wher e â€œ last(f) â€ is a ï¬lter that outputs the last output
of f . This then yields a single value 24  as r esult.
Comp osition can also b e use d to bind values to variables . The ï¬lter â€œ f as $x | g â€ p erforms the
follo wing: Giv en an input value i , for e v er y output o  of the ï¬lter f  applie d to i , the ï¬lter binds
the variable $x  to the value o , making it accessible to g , and yields the output of g  applie d to the
original input value i . For e xample , the ï¬lter â€œ (0, 2) as $x | ((1, 2) as $y | ($x + $y)) â€
yields the str eam 1, 2, 3, 4 . Note that in this particular case , w e could also write this as â€œ (0,4 FÃ¤rb er
2) + (1, 2) â€ , b e cause arithmetic op erators such as â€œ f + g â€ take as inputs the Cartesian pr o duct
of the output of f  and g . â´  Ho w e v er , ther e ar e cases wher e variables ar e indisp ensable .
â´ Haskell users might appr e ciate the similarity of the tw o ï¬lters to their Haskell analoga â€œ [0, 2] >>=
(\x -> [1, 2] >>= (\y -> return (x +y))) â€ and â€œ(+) <$> [0, 2] <*> [1, 2] â€ , which b oth r eturn
[1, 2, 3, 4] .Example 2.2  (V ariables A r e Ne cessar y ) :  jq deï¬nes a ï¬lter â€œ in(xs) â€ that e xpands to â€œ . as $x | xs
| has($x) â€ . Giv en an input value i , â€œin(xs) â€ binds it to $x , then r eturns for e v er y value pr o duce d
by xs  whether its domain contains $x  ( and thus i ). Her e , the domain of an array is the set of its
indices. For e xample , for the input 1 , the ï¬lter â€œ in([5], [42, 3], []) â€ yields the str eam false,
true, false , b e cause only [42, 3]  has a length gr eater than 1 and thus a domain that contains
1 . The p oint of this e xample is that w e wish to pass xs  as input to has , but at the same p oint, w e
also want to pass the input giv en to in  as an argument to has . Without variables, w e could not
do b oth.
Folding o v er str eams can b e done using reduce  and foreach : The ï¬lter â€œ reduce xs as $x (init;
f) â€ ke eps a state that is initialise d with the output of init . For e v er y element $x  yielde d by the
ï¬lter xs , reduce  fe e ds the curr ent state to the ï¬lter f , which may r efer ence $x , then sets the state
to the output of f . When all elements of xs  hav e b e en yielde d, reduce  r eturns the curr ent state .
For e xample , the ï¬lter â€œ reduce .[] as $x (0; . + $x) â€ calculates the sum o v er all elements of
an array . Similarly , â€œ reduce .[] as $x (0; . + 1) â€ calculates the length of an array . These tw o
ï¬lters ar e calle d â€œ add â€ and â€œlength â€ in jq, and the y allo w to calculate the av erage of an array by
â€œadd / length â€ . The ï¬lter â€œ foreach xs as $x (init; f) â€ is similar to reduce , but also yields
all interme diate states, not only the last state . For e xample , â€œ foreach .[] as $x (0; . + $x) â€
yields the cumulativ e sum o v er all array elements.
Up dating values can b e done with the op erator â€œ |= â€ , which has a similar function as lens setters
in languages such as Haskell [6] â€“ [8] : Intuitiv ely , the ï¬lter â€œ p |= f â€ considers any value v  r eturne d
by p  and r eplaces it by the output of f  applie d to v . W e call a ï¬lter on the left-hand side of â€œ |= â€ a
path e xpr ession . For e xample , when giv en the input [1, 2, 3] , the ï¬lter â€œ .[] |= (. + 1) â€ yields
[2, 3, 4] , and the ï¬lter â€œ .[1] |= (. + 1) â€ yields [1, 3, 3] . W e can also nest these ï¬lters;
for e xample , when giv en the input [[1, 2], [3, 4]] , the ï¬lter â€œ (.[] | .[]) |= (. + 1) â€
yields [[2, 3], [4, 5]] . Ho w e v er , not e v er y ï¬lter is a path e xpr ession; for e xample , the ï¬lter
â€œ1 â€ is not a path e xpr ession b e cause â€œ 1 â€ do es not p oint to any part of the input value but cr eates
a ne w value .
Identities such as â€œ .[] |= f â€ b eing e quivalent to â€œ [.[] | f] â€ when the input value is an array ,
or â€œ. |= f â€ b eing e quivalent to f , w ould allo w deï¬ning the b ehaviour of up dates. Ho w e v er , these
identities do not hold in jq due the way it handles ï¬lters f  that r eturn multiple values. In particular ,
when w e pass 0  to the ï¬lter â€œ . |= (1, 2) â€ , the output is 1 , not (1, 2)  as w e might hav e e xp e cte d.
Similarly , when w e pass [1, 2]  to the ï¬lter â€œ .[] |= (., .) â€ , the output is [1, 2] , not [1, 1, 2,
2]  as e xp e cte d. This b ehaviour of jq is cumb ersome to deï¬ne and to r eason ab out. This motivates
in part the deï¬nition of mor e simple and elegant semantics that b ehav e like jq in most typical use
cases but eliminate corner cases like the ones sho wn. W e will sho w such semantics in Se ctionÂ 6 .
3 SYNT AX
This se ction describ es the syntax for a subset of the jq language that will b e use d later to deï¬ne
the semantics in Se ctionÂ  5 . T o set the formal syntax apart fr om the concr ete syntax intr o duce d in
Se ctionÂ  2 , w e use cursiv e font ( as in â€œ ğ‘“ â€ , â€œ ğ‘£ â€) for the sp e ciï¬cation instead of the pr e viously use d
typ e writer font ( as in â€œ f â€ , â€œv â€).A formal sp e cification of the jq language 5
W e will start by intr o ducing high-le v el interme diate r epr esentation (HIR) syntax in Se ctionÂ  3.1 .
This syntax is v er y close to actual jq syntax. Then, w e will identify a subset of HIR as mid-le v el
interme diate r epr esentation (MIR) in Se ctionÂ  3.2  and pr o vide a way to translate fr om HIR to MIR.
This will simplify our semantics in Se ctionÂ  5 . Finally , in Se ctionÂ  3.3 , w e will sho w ho w HIR r elates
to actual jq syntax.
3.1 HIR
A ï¬lter  ğ‘“  is deï¬ne d by
ğ‘“ â‰” ğ‘› â€– ğ‘  â€– .
â€– ( ğ‘“ ) â€– ğ‘“ ? â€– [ ğ‘“ ] â€– { ğ‘“ : ğ‘“ , â€¦ , ğ‘“ : ğ‘“ } â€– ğ‘“ ğ‘?â€¦ ğ‘?
â€– ğ‘“ â‹† ğ‘“ â€– ğ‘“ âš¬ ğ‘“
â€– ğ‘“ as $ ğ‘¥ | ğ‘“ â€– ğœ™ ğ‘“ as $ ğ‘¥ ( ğ‘“ ; ğ‘“ ) â€– $ ğ‘¥
â€– label $ ğ‘¥ | ğ‘“ â€– break $ ğ‘¥
â€– if ğ‘“ then ğ‘“ else ğ‘“ â€– try ğ‘“ catch ğ‘“
â€– ğ‘¥ â€– ğ‘¥ ( ğ‘“ ; â€¦ ; ğ‘“ )
wher e ğ‘  is a path part of the shap e
ğ‘ â‰” [ ] â€– [ ğ‘“ ] â€– [ ğ‘“ : ] â€– [ : ğ‘“ ] â€– [ ğ‘“ : ğ‘“ ] ,
ğ‘¥  is an identiï¬er ( such as â€œ emptyâ€), ğ‘›  is a numb er ( such as 4 2  or 3 . 1 4 ), and ğ‘   is a string ( such as
â€œHello w orld!â€). W e use the sup erscript â€œ ? â€ to denote an optional pr esence of â€œ?â€; in particular ,
ğ‘“ ğ‘?â€¦ ğ‘? can b e ğ‘“ ğ‘ , ğ‘“ ğ‘ ? , ğ‘“ ğ‘ ğ‘ , ğ‘“ ğ‘ ? ğ‘ , ğ‘“ ğ‘ ğ‘ ? , ğ‘“ ğ‘ ? ğ‘ ? , ğ‘“ ğ‘ ğ‘ ğ‘ , and so on. The p otential instances of the
op erators â‹†  and âš¬  ar e giv en in T ableÂ  1 . All op erators â‹†  and âš¬  ar e left-asso ciativ e , e xcept for â€œ | â€ ,
â€œ = â€ , â€œ âŠ§ â€ , and â€œ âŠ™ = â€ . A folding op eration ğœ™  is either â€œr e duce â€ or â€œfor eachâ€ .
Name Symb ol Op erators
Comple x â‹† â€œ | â€ , â€œ , â€ , (â€œ=â€ , â€œ âŠ§ â€ , â€œ âŠ™ = â€ , â€œ â«½ = â€), â€œ â«½ â€ , â€œ orâ€ , â€œandâ€
Cartesian âš¬ ( â‰Ÿ , â‰  ), ( < , â‰¤ , > , â‰¥ ), âŠ™
Arithmetic âŠ™ ( + , âˆ’ ), ( Ã— , Ã· ), %
T ableÂ 1:  Binar y op erators, giv en in or der of incr easing pr e ce dence . Op erators surr ounde d by
par entheses hav e e qual pr e ce dence .A ï¬lter deï¬nition  has the shap e â€œ ğ‘“ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğ‘” â€ . Her e , ğ‘“  is an ğ‘› -ar y ï¬lter with ï¬lter argu-
ments  ğ‘¥ğ‘– , wher e ğ‘”  may r efer to ğ‘¥ğ‘– . For e xample , this allo ws us to deï¬ne ï¬lters that pr o duce the
b o oleans, by deï¬ning true() â‰” ( 0 = 0 )  and false() â‰” ( 0 â‰  0 ) .
W e ar e assuming a fe w pr e conditions that must b e fulï¬lle d for a ï¬lter to b e w ell-forme d. For
this, w e consider a deï¬nition ğ‘¥ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğœ‘ :
â€¢ Arguments must b e b ound: The only ï¬lter arguments that ğœ‘  can r efer to ar e ğ‘¥1 , â€¦ , ğ‘¥ğ‘› .
â€¢ Lab els must b e b ound: If ğœ‘  contains a statement break $ ğ‘¥ , then it must o ccur as a subterm of
ğ‘” , wher e label $ ğ‘¥ | ğ‘”  is a subterm of ğœ‘ .
â€¢ V ariables must b e b ound: If ğœ‘  contains any o ccurr ence of a variable $ ğ‘¥ , then it must o ccur as a
subterm of ğ‘” , wher e either ğ‘“ as $ ğ‘¥ | ğ‘”  or ğœ™ ğ‘¥ as $ ğ‘¥ ( ğ‘¦ ; ğ‘” )  is a subterms of ğœ‘ .6 FÃ¤rb er
3.2 MIR
W e ar e no w going to identify a subset of HIR calle d MIR and sho w ho w to lo w er  a HIR ï¬lter to a
semantically e quivalent MIR ï¬lter .
A MIR ï¬lter ğ‘“  has the shap e
ğ‘“ â‰” ğ‘› â€– ğ‘  â€– .
â€– [ ğ‘“ ] â€– { } â€– { ğ‘“ : ğ‘“ } â€– . ğ‘
â€– ğ‘“ â‹† ğ‘“ â€– $ ğ‘¥ âš¬ $ ğ‘¥
â€– ğ‘“ as $ ğ‘¥ | ğ‘“ â€– ğœ™ ğ‘“ as $ ğ‘¥ ( . ; ğ‘“ ) â€– $ ğ‘¥
â€– if $ ğ‘¥ then ğ‘“ else ğ‘“ â€– try ğ‘“ catch ğ‘“
â€– label $ ğ‘¥ | ğ‘“ â€– break $ ğ‘¥
â€– ğ‘¥ â€– ğ‘¥ ( ğ‘“ ; â€¦ ; ğ‘“ )
wher e ğ‘  is a path part of the shap e
ğ‘ â‰” [ ] â€– [ $ ğ‘¥ ] â€– [ $ ğ‘¥ : $ ğ‘¥ ] .
Furthermor e , the set of comple x op erators â‹†  in MIR do es not include â€œ = â€ and â€œ âŠ™ = â€ anymor e .
Compar e d to HIR, MIR ï¬lters hav e signiï¬cantly simpler path op erations ( . ğ‘  v ersus ğ‘“ ğ‘?â€¦ ğ‘?)
and r eplace certain o ccurr ences of ï¬lters by variables ( e .g. $ ğ‘¥ âš¬ $ ğ‘¥  v ersus ğ‘“ âš¬ ğ‘“ ).
T ableÂ  2  sho ws ho w to lo w er an HIR ï¬lter ğœ‘  to a semantically e quivalent MIR ï¬lter âŒŠ ğœ‘ âŒ‹ . In
particular , this desugars path op erations and makes it e xplicit which op erations ar e Cartesian
or comple x. By conv ention, w e write $ ğ‘¥â€² to denote a fr esh variable . Notice that for some com-
ple x op erators â‹† , namely â€œ = â€ , â€œ âŠ™ = â€ , â€œ â«½ = â€ , â€œ and â€ , and â€œ or â€ , T ableÂ  2  sp e ciï¬es individual lo w erings,
wher eas for the r emaining comple x op erators â‹† , namely â€œ | â€ , â€œ , â€ , â€œ âŠ§ â€ , and â€œ â«½ â€ , T ableÂ  2  sp e ciï¬es a
uniform lo w ering âŒŠ ğ‘“ â‹† ğ‘” âŒ‹ = âŒŠ ğ‘“ âŒ‹ â‹† âŒŠ ğ‘” âŒ‹ .
ğ‘?âŒŠ ğ‘?âŒ‹$ ğ‘¥
[ ]?. [ ]?
[ ğ‘“ ]?( $ ğ‘¥ | âŒŠ ğ‘“ âŒ‹ ) as $ ğ‘¦â€²| . [ $ ğ‘¦â€²]?
[ ğ‘“ : ]?( $ ğ‘¥ | âŒŠ ğ‘“ âŒ‹ ) as $ ğ‘¦â€²| length ( )?as $ ğ‘§â€²| . [ $ ğ‘¦â€²: $ ğ‘§â€²]?
[ : ğ‘“ ]?( $ ğ‘¥ | âŒŠ ğ‘“ âŒ‹ ) as $ ğ‘¦â€²| 0 as $ ğ‘§â€²| . [ $ ğ‘§â€²: $ ğ‘¦â€²]?
[ ğ‘“ : ğ‘” ]?( $ ğ‘¥ | âŒŠ ğ‘“ âŒ‹ ) as $ ğ‘¦â€²| ( $ ğ‘¥ | âŒŠ ğ‘” âŒ‹ ) as $ ğ‘§â€²| . [ $ ğ‘¦â€²: $ ğ‘§â€²]?
T ableÂ 3: Lo w ering of a path part ğ‘? with input $ ğ‘¥  to a MIR ï¬lter .T ableÂ  3  sho ws ho w to lo w er a path part ğ‘? to MIR ï¬lters. Like in Se ctionÂ  3.1 , the meaning of
sup erscript â€œ ? â€ is an optional pr esence of â€œ ? â€ . In the lo w ering of ğ‘“ ğ‘?
1 â€¦ ğ‘?
ğ‘›  in T ableÂ  2 , if ğ‘ğ‘–  in the ï¬rst
column is dir e ctly follo w e d by â€œ?â€ , then âŒŠ ğ‘?
ğ‘– âŒ‹$ ğ‘¥ in the se cond column stands for âŒŠ ğ‘ğ‘– ? âŒ‹$ ğ‘¥, other wise
for âŒŠ ğ‘ğ‘– âŒ‹$ ğ‘¥. Similarly , in T ableÂ  3 , if ğ‘  in the ï¬rst column is follo w e d by â€œ ? â€ , then all o ccurr ences of
sup erscript â€œ?â€ in the se cond column stand for â€œ?â€ , other wise for nothing.
Example 3.2.1 :  The HIR ï¬lter ( . [ ] ? [ ] )  is lo w er e d to ( . as $ ğ‘¥â€²| . | . [ ] ? | . [ ] ) . Semantically , w e will
se e that this is e quivalent to ( . [ ] ? | . [ ] ) .
Example 3.2.2 :  The HIR ï¬lter ğœ‡ â‰¡ . [ 0 ]  is lo w er e d to âŒŠ ğœ‡ âŒ‹ â‰¡ . as $ ğ‘¥ | . | ( $ ğ‘¥ | 0 ) as $ ğ‘¦ | . [ $ ğ‘¦ ] .
Semantically , w e will se e that âŒŠ ğœ‡ âŒ‹  is e quivalent to 0 as $ ğ‘¦ | . [ $ ğ‘¦ ] .A formal sp e cification of the jq language 7
ğœ‘ âŒŠ ğœ‘ âŒ‹
ğ‘› , ğ‘  , . , $ ğ‘¥ , or break $ ğ‘¥ ğœ‘
( ğ‘“ ) âŒŠ ğ‘“ âŒ‹
ğ‘“ ? try âŒŠ ğ‘“ âŒ‹ catch empty ( )
[ ] [ empty ( ) ]
[ ğ‘“ ] [ âŒŠ ğ‘“ âŒ‹ ]
{ } { }
{ ğ‘“ : ğ‘” } âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| âŒŠ ğ‘” âŒ‹ as $ ğ‘¦â€²| { $ ğ‘¥â€²: $ ğ‘¦â€²}
{ ğ‘“1 : ğ‘”1 , â€¦ , ğ‘“ğ‘› : ğ‘”ğ‘› } âŒŠ âˆ‘ğ‘–{ ğ‘“ğ‘– : ğ‘”ğ‘– } âŒ‹
ğ‘“ ğ‘?
1 â€¦ ğ‘?
ğ‘› . as $ ğ‘¥â€²| âŒŠ ğ‘“ âŒ‹ | âŒŠ ğ‘?
1 âŒ‹$ ğ‘¥â€²| â€¦ | âŒŠ ğ‘?
ğ‘› âŒ‹$ ğ‘¥â€²
ğ‘“ = ğ‘” âŒŠ ğ‘” âŒ‹ as $ ğ‘¥â€²| âŒŠ ğ‘“ âŠ§ $ ğ‘¥â€²âŒ‹
ğ‘“ âŠ™ = ğ‘” âŒŠ ğ‘“ âŠ§ . âŠ™ ğ‘” âŒ‹
ğ‘“ â«½ = ğ‘” âŒŠ ğ‘“ âŠ§ . â«½ ğ‘” âŒ‹
ğ‘“ and ğ‘” âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| $ ğ‘¥â€²and âŒŠ ğ‘” âŒ‹
ğ‘“ or ğ‘” âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| $ ğ‘¥â€²or âŒŠ ğ‘” âŒ‹
ğ‘“ â‹† ğ‘” âŒŠ ğ‘“ âŒ‹ â‹† âŒŠ ğ‘” âŒ‹
ğ‘“ âš¬ ğ‘” âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| âŒŠ ğ‘” âŒ‹ as $ ğ‘¦â€²| $ ğ‘¥ âš¬ $ ğ‘¦
ğ‘“ as $ ğ‘¥ | ğ‘” âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥ | âŒŠ ğ‘” âŒ‹
ğœ™ ğ‘“ğ‘¥ as $ ğ‘¥ ( ğ‘“ğ‘¦ ; ğ‘“ ) . as $ ğ‘¥â€²| âŒŠ ğ‘“ğ‘¦ âŒ‹ | ğœ™ âŒŠ $ ğ‘¥â€²| ğ‘“ğ‘¥ âŒ‹ as $ ğ‘¥ ( . ; âŒŠ ğ‘“ âŒ‹ )
if ğ‘“ğ‘¥ then ğ‘“ else ğ‘” âŒŠ ğ‘“ğ‘¥ âŒ‹ as $ ğ‘¥â€²| if $ ğ‘¥â€²then âŒŠ ğ‘“ âŒ‹ else âŒŠ ğ‘” âŒ‹
try ğ‘“ catch ğ‘” try âŒŠ ğ‘“ âŒ‹ catch âŒŠ ğ‘” âŒ‹
label $ ğ‘¥ | ğ‘“ label $ ğ‘¥ | âŒŠ ğ‘“ âŒ‹
ğ‘¥ ğ‘¥
ğ‘¥ ( ğ‘“1 ; â€¦ ; ğ‘“ğ‘› ) ğ‘¥ ( âŒŠ ğ‘“1 âŒ‹ ; â€¦ ; âŒŠ ğ‘“ğ‘› âŒ‹ )
T ableÂ 2: Lo w ering of a HIR ï¬lter ğœ‘  to a MIR ï¬lter âŒŠ ğœ‘ âŒ‹ .
The HIR ï¬lter ğœ‘ â‰¡ [ 3 ] | . [ 0 ] = ( length ( ) , 2 )  is lo w er e d to the MIR ï¬lter
âŒŠ ğœ‘ âŒ‹ â‰¡ [ 3 ] | ( length ( ) , 2 ) as $ ğ‘§ | âŒŠ ğœ‡ âŒ‹ âŠ§ $ ğ‘§ . In Se ctionÂ 5 , w e will se e that its output is âŸ¨ [ 1 ] , [ 2 ] âŸ© .
This lo w ering assumes the pr esence of one ï¬lter in the deï¬nitions, namely empty . This ï¬lter r e-
turns an empty str eam. W e might b e tempte d to deï¬ne it as { } | . [ ] , which constructs an empty
obje ct, then r eturns its containe d values, which corr esp onds to an empty str eam as w ell. Ho w e v er ,
such a deï¬nition r elies on the temp orar y construction of ne w values ( such as the empty obje ct
her e), which is not admissible on the left-hand side of up dates ( se e Se ctionÂ  6 ). For this r eason, w e
hav e to deï¬ne it in a mor e complicate d way , for e xample
empty ( ) â‰” ( { } | . [ ] ) as $ ğ‘¥ | .
This deï¬nition ensur es that empty  can b e emplo y e d also as a path e xpr ession.8 FÃ¤rb er
The lo w ering in T ableÂ  2  is compatible with the semantics of the jq implementa-
tion, with one notable e xception: In jq, Cartesian op erations ğ‘“ âš¬ ğ‘”  w ould b e lo w er e d to
âŒŠ ğ‘” âŒ‹ as $ ğ‘¦â€²| âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| $ ğ‘¥ âš¬ $ ğ‘¦ , wher eas w e lo w er it to âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| âŒŠ ğ‘” âŒ‹ as $ ğ‘¦â€²| $ ğ‘¥ âš¬ $ ğ‘¦ , thus
inv erting the binding or der . Note that the diï¬€er ence only sho ws when b oth ğ‘“  and ğ‘”  r eturn multiple
values. W e div erge her e fr om jq to make the lo w ering of Cartesian op erations consistent with that
of other op erators, such as { ğ‘“ : ğ‘” } , wher e the leftmost ï¬lter ( ğ‘“ ) is b ound ï¬rst and the rightmost ï¬l-
ter ( ğ‘” ) is b ound last. That also makes it easier to describ e other ï¬lters, such as { ğ‘“1 : ğ‘”1 , â€¦ , ğ‘“ğ‘› : ğ‘”ğ‘› } ,
which w e can lo w er to âŒŠ âˆ‘ğ‘–{ ğ‘“ğ‘– : ğ‘”ğ‘– } âŒ‹ , wher eas its lo w ering assuming the jq lo w ering of Cartesian
op erations w ould b e âŒŠ { ğ‘“1 : ğ‘”1 } âŒ‹ as $ ğ‘¥â€²
1 | â€¦ | âŒŠ { ğ‘“ğ‘› : ğ‘”ğ‘› } âŒ‹ as $ ğ‘¥â€²
ğ‘› | âˆ‘ğ‘–$ ğ‘¥â€²
ğ‘– .
Example 3.2.3 :  The ï¬lter ( 0 , 2 ) + ( 0 , 1 )  yields âŸ¨ 0 , 1 , 2 , 3 âŸ©  using our lo w ering, and âŸ¨ 0 , 2 , 1 , 3 âŸ©  in jq.
3.3 CONCRETE JQ SYNT AX
Let us no w go a le v el ab o v e HIR, namely a subset of actual jq syntax âµ  of which w e hav e se en
e xamples in Se ctionÂ 2 , and sho w ho w to transform jq pr ograms to HIR and to MIR.
âµ A ctual jq syntax has a fe w mor e constructions to oï¬€er , including neste d deï¬nitions, variable
arguments, string interp olation, mo dules, etc. Ho w e v er , these constructions can b e transforme d into
semantically e quivalent syntax as tr eate d in this te xt.A pr ogram  is a (p ossibly empty ) se quence of deï¬nitions, follo w e d by a main ï¬lter  f . A deï¬ni-
tion  has the shap e def x(x1; ...; xn): g;  or def x: g ; wher e x  is an identiï¬er , x1  to xn  is
a non-empty se quence of semicolon-separate d identiï¬ers, and g  is a ï¬lter . In HIR, w e write the
corr esp onding deï¬nition as ğ‘¥ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğ‘” .
The syntax of ï¬lters in concr ete jq syntax is nearly the same as in HIR. T o translate b etw e en
the op erators in T ableÂ  1 , se e T ableÂ  4 . The arithmetic up date op erators in jq, namely += , -= , *= , /
= , and %= , corr esp ond to the op erators âŠ™ =  in HIR, namely + = , âˆ’ = , Ã— = , Ã· = , and % = . Filters of
the shap e if f then g else h end  corr esp ond to the ï¬lter if ğ‘“ then ğ‘” else â„  in HIR; that is, in
HIR, the ï¬nal end  is omitte d.
In jq, it is invalid syntax to call a nullar y ï¬lter as x()  instead of x , or to deï¬ne a nullar y ï¬lter
as def x(): f;  instead of def x: f; . On the other hand, on the right-hand side of a deï¬nition,
x  may r efer either to a ï¬lter argument x  or a nullar y ï¬lter x . T o ease our liv es when deï¬ning
the semantics, w e allo w the syntax ğ‘¥ ( )  in HIR. W e unambiguously interpr et ğ‘¥  as call to a ï¬lter
argument and ğ‘¥ ( )  as call to a ï¬lter that was deï¬ne d as ğ‘¥ ( ) â‰” ğ‘“ .
jq|,=|=//=//==!=<<=>>=+-*/%
HIR | , = âŠ§ â«½ = â«½ â‰Ÿ â‰  < â‰¤ > â‰¥ + âˆ’ Ã— Ã· %
T ableÂ 4: Op erators in concr ete jq syntax and their corr esp onding HIR op erators.T o conv ert a jq pr ogram to MIR, w e do the follo wing:
1. For each deï¬nition, conv ert it to a HIR deï¬nition.
2. Conv ert the main ï¬lter f  to a HIR ï¬lter ğ‘“ .
3. Replace the right-hand sides of HIR deï¬nitions and ğ‘“  by their lo w er e d MIR counterparts, us-
ing T ableÂ 2 .
Example 3.3.1 :  Consider the jq pr ogram def recurse(f): ., (f | recurse(f)); recurse(.
+ 1) , which r eturns the inï¬nite str eam of output values ğ‘› , ğ‘› + 1 , â€¦  when pr o vide d with
an input numb er ğ‘› . The deï¬nition in this e xample can b e conv erte d to the HIR deï¬ni-
tion recurse ( ğ‘“ ) â‰” . , ( ğ‘“ | recurse ( ğ‘“ ) )  and the main ï¬lter can b e conv erte d to the HIR ï¬lterA formal sp e cification of the jq language 9
recurse ( . + 1 ) . The lo w ering of the deï¬nition to MIR yields the same as the HIR deï¬nition, and
the lo w ering of the main ï¬lter to MIR yields recurse ( . as $ ğ‘¥â€²| 1 as $ ğ‘¦â€²| $ ğ‘¥â€²+ $ ğ‘¦â€²) .
Example 3.3.2 :  Consider the jq pr ogram def select(f): if f then . else empty end;
def negative : . < 0; .[] | select(negative) . When giv en an array as an input, it yields
those elements of the array that ar e smaller than 0 . Her e , the deï¬nitions in the e xample ar e
conv erte d to the HIR deï¬nitions select ( ğ‘“ ) â‰” if ğ‘“ then . else empty ( )  and negative ( ) â‰” . < 0 ,
and the main ï¬lter is conv erte d to the HIR ï¬lter . [ ] | select ( negative ( ) ) . Both the deï¬nition of
select ( ğ‘“ )  and the main ï¬lter ar e alr eady in MIR; the MIR v ersion of the r emaining deï¬nition is
negative ( ) â‰” . as $ ğ‘¥â€²| 0 as $ ğ‘¦â€²| $ ğ‘¥â€²< $ ğ‘¦â€².
W e will sho w in Se ctionÂ  5  ho w to run the r esulting MIR ï¬lter ğ‘“  in the pr esence of a set of MIR
deï¬nitions. For a giv en input value ğ‘£ , the output of ğ‘“  will b e giv en by ğ‘“ |{ }
ğ‘£ .
4 V ALUES
In this se ction, w e will deï¬ne JSON values, err ors, e xceptions, and str eams. Furthermor e , w e will
deï¬ne se v eral functions and op erations on values.
A JSON value ğ‘£  has the shap e
ğ‘£ â‰” null â€– false â€– true â€– ğ‘› â€– ğ‘  â€– [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] â€– { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› } ,
wher e ğ‘›  is a numb er and ğ‘   is a string. W e write a string ğ‘   as ğ‘0 â€¦ ğ‘ğ‘› , wher e ğ‘  is a character . A
value of the shap e [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]  is calle d an array  and a value of the shap e { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› }
is an unor der e d map fr om ke ys  ğ‘˜  to values that w e call an obje ct . â¶  In JSON, obje ct ke ys ar e
â¶ The JSON syntax uses { ğ‘˜0 : ğ‘£0 , â€¦ , ğ‘˜ğ‘› : ğ‘£ğ‘› }  instead of { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› } . Ho w e v er , in this
te xt, w e will use the { ğ‘˜0 : ğ‘£0 , â€¦ , ğ‘˜ğ‘› : ğ‘£ğ‘› }  syntax to denote the construction  of obje cts, and use
{ ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› }  syntax to denote actual obje cts.strings. â·  W e assume that the union of tw o obje cts is right-biase d ; i.e ., if w e hav e tw o obje cts ğ‘™  and
ğ‘Ÿ = { ğ‘˜ â†¦ ğ‘£ , â€¦ } , then ( ğ‘™ âˆª ğ‘Ÿ ) ( ğ‘˜ ) = ğ‘£  (r egar dless of what ğ‘™ ( ğ‘˜ )  might yield).
â· Y AML is a data format similar to JSON. While Y AML can enco de any JSON value , it additionally
allo ws any Y AML values to b e use d as obje ct ke ys, wher e JSON allo ws only strings to b e use d as obje ct
ke ys. This te xt delib erately distinguishes b etw e en obje ct ke ys and strings. That way , e xtending the
giv en semantics to use Y AML values should b e r elativ ely easy .By conv ention, w e will write in the r emainder of this te xt ğ‘£  for values, ğ‘›  for numb ers, ğ‘  for
characters, and ğ‘˜  for obje ct ke ys. W e will sometimes write arrays as [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]  and sometimes as
[ ğ‘£1 , â€¦ , ğ‘£ğ‘› ] : The former case is useful to e xpr ess that ğ‘›  is the maximal inde x of the array ( having
length ğ‘› + 1 ), and the latter case is useful to e xpr ess that the array has length ğ‘› . The same idea
applies also to strings, obje cts, and str eams.
A numb er can b e an integer or a de cimal, optionally follo w e d by an integer e xp onent. For e x-
ample , 0 , âˆ’ 4 2 , 3 . 1 4 , 3 Ã— 1 08 ar e valid JSON numb ers. This te xt do es not ï¬x ho w numb ers ar e to
b e r epr esente d, just like the JSON standar d do es not imp ose any r epr esentation. â¸  Instead, it just
â¸ jq uses ï¬‚oating-p oint numb ers to enco de b oth integers and de cimals. Ho w e v er , se v eral op erations
in this te xt (for e xample those in Se ctionÂ 4.4 ) make only sense for natural numb ers â„•  or integers â„¤ . In
situations wher e integer values ar e e xp e cte d and a numb er ğ‘›  is pr o vide d, jq generally substitutes ğ‘›  by
âŒŠ ğ‘› âŒ‹  if ğ‘› â‰¥ 0  and âŒˆ ğ‘› âŒ‰  if ğ‘› < 0 . For e xample , accessing the 0 . 5 -th element of an array yields its 0 -th
element. In this te xt, w e use do not do cument this r ounding b ehaviour for each function.assumes that the typ e of numb ers has a total or der ( se e Se ctionÂ  4.6 ) and supp orts the arithmetic
op erations + , âˆ’ , Ã— , Ã· , and %  (mo dulo).10 FÃ¤rb er
An err or  can b e constructe d fr om a value by the function error ( ğ‘£ ) . The error  function is bije ctiv e;
that is, if w e hav e an err or ğ‘’ , then ther e is a unique value ğ‘£  with ğ‘’ = error ( ğ‘£ ) . In the r emainder
of this te xt, w e will write just â€œ err orâ€ to denote calling error ( ğ‘£ )  with some value ğ‘£ . This is done
such that this sp e ciï¬cation do es not ne e d to ï¬x the pr e cise err or value that is r eturne d when an
op eration fails.
An e xception  either is an err or or has the shap e break ( $ ğ‘¥ ) . The latter will b e come r ele vant
starting fr om Se ctionÂ 5 .
A value r esult  is either a value or an e xception.
A str eam  ( or lazy list) is written as âŸ¨ ğ‘£0 , â€¦ , ğ‘£ğ‘› âŸ© . The concatenation of tw o str eams ğ‘ 1 ,
ğ‘ 2  is written as ğ‘ 1 + ğ‘ 2 . Giv en some str eam ğ‘™ = âŸ¨ ğ‘¥0 , â€¦ , ğ‘¥ğ‘› âŸ© , w e write âˆ‘ğ‘¥ âˆˆ ğ‘™ğ‘“ ( ğ‘¥ )  to denote
ğ‘“ ( ğ‘¥0 ) + â€¦ + ğ‘“ ( ğ‘¥ğ‘› ) . W e use this fr e quently to map a function o v er a str eam, by having ğ‘“ ( ğ‘¥ )  r e-
turn a str eam itself.
In this te xt, w e will se e many functions that take values as arguments. By conv ention, for any
of these functions ğ‘“ ( ğ‘£1 , â€¦ , ğ‘£ğ‘› ) , w e e xtend their domain to value r esults such that ğ‘“ ( ğ‘£1 , â€¦ , ğ‘£ğ‘› )
yields ğ‘£ğ‘–  ( or rather âŸ¨ ğ‘£ğ‘– âŸ©  if ğ‘“  r eturns str eams) if ğ‘£ğ‘–  is an e xception and for all ğ‘— < ğ‘– , ğ‘£ğ‘—  is a value . For
e xample , in Se ctionÂ  4.3 , w e will deï¬ne ğ‘™ + ğ‘Ÿ  for values ğ‘™  and ğ‘Ÿ , and by our conv ention, w e e xtend
the domain of addition to value r esults such that if ğ‘™  is an e xception, then ğ‘™ + ğ‘Ÿ  r eturns just ğ‘™ , and
if ğ‘™  is a value , but ğ‘Ÿ  is an e xception, then ğ‘™ + ğ‘Ÿ  r eturns just ğ‘Ÿ .
4.1 CONSTRUCTION
In this subse ction, w e will intr o duce op erators to construct arrays and obje cts.
The function [ â‹… ]  transforms a str eam into an array if all str eam elements ar e values, or into the
ï¬rst e xception in the str eam other wise:
[ âŸ¨ ğ‘£0 , â€¦ , ğ‘£ğ‘› âŸ© ] â‰” {ğ‘£ğ‘– if ğ‘£ğ‘– is an exception and for all ğ‘— < ğ‘– , ğ‘£ğ‘— is a value
[ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] otherwise
Giv en tw o values ğ‘˜  and ğ‘£ , w e can make an obje ct out of them:
{ ğ‘˜ : ğ‘£ } â‰” {{ ğ‘˜ â†¦ ğ‘£ } if ğ‘˜ is a string and ğ‘£ is a value
error otherwise
W e can construct obje cts with multiple ke ys by adding obje cts, se e Se ctionÂ 4.3 .
4.2 SIMPLE F UNCTIONS
W e ar e no w going to deï¬ne se v eral functions that take a value and r eturn a value .
The ke ys  of a value ar e deï¬ne d as follo ws:
keys ( ğ‘£ ) â‰”
â©{{{{{â¨{{{{{â§ âŸ¨ 0 , â€¦ , ğ‘› âŸ© if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]
âŸ¨ ğ‘˜0 âŸ© + keys ( ğ‘£â€² ) if ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 } âˆª ğ‘£â€² and ğ‘˜0 = min ( dom ( ğ‘£ ) )
âŸ¨ âŸ© if ğ‘£ = { }
âŸ¨ error âŸ© otherwise
For an obje ct ğ‘£ , keys ( ğ‘£ )  r eturns the domain of the obje ct sorte d by ascending or der . For the use d
or dering, se e Se ctionÂ 4.6 .
W e deï¬ne the length  of a value as follo ws:A formal sp e cification of the jq language 11
| ğ‘£ | â‰”
â©{{{{{{{â¨{{{{{{{â§0 if ğ‘£ = null
| ğ‘› | if ğ‘£ is a number ğ‘›
ğ‘› if ğ‘£ = ğ‘1 â€¦ ğ‘ğ‘›
ğ‘› if ğ‘£ = [ ğ‘£1 , â€¦ , ğ‘£ğ‘› ]
ğ‘› if ğ‘£ = { ğ‘˜1 â†¦ ğ‘£1 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› }
error otherwise (if ğ‘£ âˆˆ { true , false } )
The b o olean value  of a value ğ‘£  is deï¬ne d as follo ws:
bool ( ğ‘£ ) â‰” {false if ğ‘£ = null or ğ‘£ = false
true otherwise
W e can draw a link b etw e en the functions her e and jq: When calle d with the input value ğ‘£ , the jq
ï¬lter keys  yields âŸ¨ [ keys ( ğ‘£ ) ] âŸ© , the jq ï¬lter length  yields âŸ¨ | ğ‘£ | âŸ© , and the jq ï¬lter true and .  yields
âŸ¨ bool ( ğ‘£ ) âŸ© .
4.3 ARITHMETIC OPERA TIONS
W e will no w deï¬ne a set of arithmetic op erations on values. W e will link these later dir e ctly to
their counterparts in jq: Supp ose that the jq ï¬lters f  and g  yield âŸ¨ ğ‘™ âŸ©  and âŸ¨ ğ‘Ÿ âŸ© , r esp e ctiv ely . Then the
jq ï¬lters f + g , f - g , f * g , f / g , and f % g  yield âŸ¨ ğ‘™ + ğ‘Ÿ âŸ© , âŸ¨ ğ‘™ âˆ’ ğ‘Ÿ âŸ© , âŸ¨ ğ‘™ Ã— ğ‘Ÿ âŸ© , âŸ¨ ğ‘™ Ã· ğ‘Ÿ âŸ© , and âŸ¨ ğ‘™ % ğ‘Ÿ âŸ© ,
r esp e ctiv ely .
4.3.1 ADDITION
W e deï¬ne addition of tw o values ğ‘™  and ğ‘Ÿ  as follo ws:
ğ‘™ + ğ‘Ÿ â‰”
â©{{{{{â¨{{{{{â§ğ‘£ if ğ‘™ = null and ğ‘Ÿ = ğ‘£ , or ğ‘™ = ğ‘£ and ğ‘Ÿ = null
ğ‘›1 + ğ‘›2 if ğ‘™ is a number ğ‘›1 and ğ‘Ÿ is a number ğ‘›2
ğ‘ğ‘™ , 1 â€¦ ğ‘ğ‘™ , ğ‘š ğ‘ğ‘Ÿ , 1 â€¦ ğ‘ğ‘Ÿ , ğ‘› if ğ‘™ = ğ‘ğ‘™ , 1 â€¦ ğ‘ğ‘™ , ğ‘š and ğ‘Ÿ = ğ‘ğ‘Ÿ , 1 â€¦ ğ‘ğ‘Ÿ , ğ‘›
[ âŸ¨ ğ‘™1 , â€¦ , ğ‘™ğ‘š , ğ‘Ÿ1 , â€¦ , ğ‘Ÿğ‘› âŸ© ] if ğ‘™ = [ ğ‘™1 , â€¦ , ğ‘™ğ‘š ] and ğ‘Ÿ = [ ğ‘Ÿ1 , â€¦ , ğ‘Ÿğ‘› ]
ğ‘™ âˆª ğ‘Ÿ if ğ‘™ = { â€¦ } and ğ‘Ÿ = { â€¦ }
error otherwise
Her e , w e can se e that null  ser v es as a neutral element for addition. For strings and arrays, addition
corr esp onds to their concatenation, and for obje cts, it corr esp onds to their union.
4.3.2 MULTIPLICA TION
Giv en tw o obje cts ğ‘™  and ğ‘Ÿ , w e deï¬ne their r e cursiv e merge  ğ‘™ â‹“ ğ‘Ÿ  as:
ğ‘™ â‹“ ğ‘Ÿ â‰”
â©{{{â¨{{{â§ { ğ‘˜ â†¦ ğ‘£ğ‘™ â‹“ ğ‘£ğ‘Ÿ } âˆª ğ‘™â€² â‹“ ğ‘Ÿâ€² if ğ‘™ = { ğ‘˜ â†¦ ğ‘£ğ‘™ } âˆª ğ‘™â€² , ğ‘Ÿ = { ğ‘˜ â†¦ ğ‘£ğ‘Ÿ } âˆª ğ‘Ÿâ€² , and ğ‘£ğ‘™ , ğ‘£ğ‘Ÿ are objects
{ ğ‘˜ â†¦ ğ‘£ğ‘Ÿ } âˆª ğ‘™â€² â‹“ ğ‘Ÿâ€² if ğ‘™ = { ğ‘˜ â†¦ ğ‘£ğ‘™ } âˆª ğ‘™â€² , ğ‘Ÿ = { ğ‘˜ â†¦ ğ‘£ğ‘Ÿ } âˆª ğ‘Ÿâ€² , and ğ‘£ğ‘™ or ğ‘£ğ‘Ÿ is not an object
{ ğ‘˜ â†¦ ğ‘£ğ‘Ÿ } âˆª ğ‘™ â‹“ ğ‘Ÿâ€² if ğ‘˜ âˆ‰ dom ( ğ‘™ ) and ğ‘Ÿ = { ğ‘˜ â†¦ ğ‘£ğ‘Ÿ } âˆª ğ‘Ÿâ€²
ğ‘™ otherwise (if ğ‘Ÿ = { } )
W e use this in the follo wing deï¬nition of multiplication of tw o values ğ‘™  and ğ‘Ÿ :12 FÃ¤rb er
ğ‘™ Ã— ğ‘Ÿ â‰”
â©{{{{â¨{{{{â§ğ‘›1 Ã— ğ‘›2 if ğ‘™ is a number ğ‘›1 and ğ‘Ÿ is a number ğ‘›2
ğ‘™ + ğ‘™ Ã— ( ğ‘Ÿ âˆ’ 1 ) if ğ‘™ is a string and ğ‘Ÿ âˆˆ â„• âˆ– { 0 }
null if ğ‘™ is a string and ğ‘Ÿ = 0
ğ‘Ÿ Ã— ğ‘™ if ğ‘Ÿ is a string and ğ‘™ âˆˆ â„•
ğ‘™ â‹“ ğ‘Ÿ if ğ‘™ and ğ‘Ÿ are objects
error otherwise
W e can se e that multiplication of a string ğ‘   with a natural numb er ğ‘› > 0  r eturns âˆ‘ğ‘›
ğ‘– = 1ğ‘  ; that is,
the concatenation of ğ‘›  times the string ğ‘  . The multiplication of tw o obje cts corr esp onds to their
r e cursiv e merge as deï¬ne d ab o v e .
4.3.3 SUBTRA CTION
W e no w deï¬ne subtraction of tw o values ğ‘™  and ğ‘Ÿ :
ğ‘™ âˆ’ ğ‘Ÿ â‰”
â©{{â¨{{â§ ğ‘›1 âˆ’ ğ‘›2 if ğ‘™ is a number ğ‘›1 and ğ‘Ÿ is a number ğ‘›2
[ âˆ‘ğ‘– , ğ‘™ğ‘– âˆˆ { ğ‘Ÿ0 , â€¦ , ğ‘Ÿğ‘› }âŸ¨ ğ‘™ğ‘– âŸ© ] if ğ‘™ = [ ğ‘™0 , â€¦ , ğ‘™ğ‘› ] and ğ‘Ÿ = [ ğ‘Ÿ0 , â€¦ , ğ‘Ÿğ‘› ]
error otherwise
When b oth ğ‘™  and ğ‘Ÿ  ar e arrays, then ğ‘™ âˆ’ ğ‘Ÿ  r eturns an array containing those values of ğ‘™  that ar e not
containe d in ğ‘Ÿ .
4.3.4 DI VISION
W e will no w deï¬ne a function that splits a string ğ‘¦ + ğ‘¥  by some non-empty separator string ğ‘  .
The function pr eser v es the invariant that ğ‘¦  do es not contain ğ‘  :
split ( ğ‘¥ , ğ‘  , ğ‘¦ ) â‰”
â©{{â¨{{â§ split ( ğ‘1 â€¦ ğ‘ğ‘› , ğ‘  , ğ‘¦ + ğ‘0 ) if ğ‘¥ = ğ‘0 â€¦ ğ‘ğ‘› and ğ‘0 â€¦ ğ‘| ğ‘  | âˆ’ 1 â‰  ğ‘ 
[ âŸ¨ ğ‘¦ âŸ© ] + split ( ğ‘| ğ‘  | â€¦ ğ‘ğ‘› , ğ‘  , " " ) if ğ‘¥ = ğ‘0 â€¦ ğ‘ğ‘› and ğ‘0 â€¦ ğ‘| ğ‘  | âˆ’ 1 = ğ‘ 
[ âŸ¨ ğ‘¦ âŸ© ] otherwise ( | ğ‘¥ | = 0 )
W e use this splitting function to deï¬ne division of tw o values:
ğ‘™ Ã· ğ‘Ÿ â‰”
â©{{{{â¨{{{{â§ğ‘›1 Ã· ğ‘›2 if ğ‘™ is a number ğ‘›1 and ğ‘Ÿ is a number ğ‘›2
[ ] if ğ‘™ and ğ‘Ÿ are strings and | ğ‘™ | = 0
[ âˆ‘ğ‘–âŸ¨ ğ‘ğ‘– âŸ© ] if ğ‘™ = ğ‘0 â€¦ ğ‘ğ‘› , ğ‘Ÿ is a string, | ğ‘™ | > 0 , and | ğ‘Ÿ | = 0
split ( ğ‘™ , ğ‘Ÿ , " " ) if ğ‘™ and ğ‘Ÿ are strings, | ğ‘™ | > 0 , and | ğ‘Ÿ | > 0
error otherwise
Example 4.3.4.1 :  Let ğ‘  = " ab " . W e hav e that ğ‘  Ã· ğ‘  = [ " " , " " ] . Furthermor e , " ğ‘ " Ã· ğ‘  = [ " ğ‘ " ] ,
( ğ‘  + " ğ‘ " + ğ‘  ) Ã· ğ‘  = [ " " , " ğ‘ " , " " ]  and ( ğ‘  + " ğ‘ " + ğ‘  + " de " ) Ã· ğ‘  = [ " " , " ğ‘ " , " de " ] .
Fr om this e xample , w e can infer the follo wing lemma.
Lemma 4.3.4.1 :  Let ğ‘™  and ğ‘Ÿ  strings with | ğ‘™ | > 0  and | ğ‘Ÿ | > 0 . Then ğ‘™ Ã· ğ‘Ÿ = [ ğ‘™0 , â€¦ , ğ‘™ğ‘› ]  for some ğ‘› > 0
such that ğ‘™ = ( âˆ‘ğ‘› âˆ’ 1
ğ‘– = 0( ğ‘™ğ‘– + ğ‘Ÿ ) ) + ğ‘™ğ‘›  and for all ğ‘– , ğ‘™ğ‘–  is a string that do es not contain ğ‘Ÿ  as substring.A formal sp e cification of the jq language 13
4.3.5 REMAINDER
For tw o values ğ‘™  and ğ‘Ÿ , the arithmetic op eration ğ‘™ % ğ‘Ÿ  (mo dulo) yields ğ‘š % ğ‘›  if ğ‘™  and ğ‘Ÿ  ar e numb ers
ğ‘š  and ğ‘› , other wise it yields an err or .
4.4 A CCESSING
W e will no w deï¬ne thr e e access op erators . These ser v e to e xtract values that ar e containe d within
other values.
The value ğ‘£ [ ğ‘– ]  of a value ğ‘£  at inde x ğ‘–  is deï¬ne d as follo ws:
ğ‘£ [ ğ‘– ] â‰”
â©{{{{{â¨{{{{{â§ğ‘£ğ‘– if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– âˆˆ â„• , and ğ‘– â‰¤ ğ‘›
null if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– âˆˆ â„• , and ğ‘– > ğ‘›
ğ‘£ [ ğ‘› + ğ‘– ] if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘–
ğ‘£ğ‘— if ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› } , ğ‘– is a string, and ğ‘˜ğ‘— = ğ‘–
null if ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› } , ğ‘– is a string, and ğ‘– âˆ‰ { ğ‘˜0 , â€¦ , ğ‘˜ğ‘› }
error otherwise
The idea b ehind this inde x op erator is as follo ws: It r eturns null  if the value ğ‘£  do es not contain a
value at inde x ğ‘– , but ğ‘£  could b e e xtende d  to contain one . Mor e formally , ğ‘£ [ ğ‘– ]  is null  if ğ‘£ â‰  null  and
ther e e xists some value ğ‘£â€²= ğ‘£ + ğ›¿  such that ğ‘£â€²[ ğ‘– ] â‰  null .
The b ehaviour of this op erator for ğ‘– < 0  is that ğ‘£ [ ğ‘– ]  e quals ğ‘£ [ | ğ‘£ | + ğ‘– ] .
Example 4.4.1 :  If ğ‘£ = [ 0 , 1 , 2 ] , then ğ‘£ [ 1 ] = 1  and ğ‘£ [ âˆ’ 1 ] = ğ‘£ [ 3 âˆ’ 1 ] = 2 .
Using the inde x op erator , w e can deï¬ne the values ğ‘£ [ ]  in a value ğ‘£  as follo ws:
ğ‘£ [ ] â‰” âˆ‘
ğ‘– âˆˆ keys ( ğ‘£ )âŸ¨ ğ‘£ [ ğ‘– ] âŸ©
When pr o vide d with an array ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]  or an obje ct ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› }  ( wher e
ğ‘˜0 < â€¦ < ğ‘˜ğ‘› ), ğ‘£ [ ]  r eturns the str eam âŸ¨ ğ‘£0 , â€¦ , ğ‘£ğ‘› âŸ© .
The last op erator that w e deï¬ne her e is a slice op erator:
ğ‘£ [ ğ‘– : ğ‘— ] â‰”
â©{{{{â¨{{{{â§[ âˆ‘ğ‘— âˆ’ 1
ğ‘˜ = ğ‘–âŸ¨ ğ‘£ğ‘˜ âŸ© ] if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] and ğ‘– , ğ‘— âˆˆ â„•
âˆ‘ğ‘— âˆ’ 1
ğ‘˜ = ğ‘–ğ‘ğ‘˜ if ğ‘£ = ğ‘0 â€¦ ğ‘ğ‘› and ğ‘– , ğ‘— âˆˆ â„•
ğ‘£ [ ( ğ‘› + ğ‘– ) : ğ‘— ] if | ğ‘£ | = ğ‘› , ğ‘– âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘–
ğ‘£ [ ğ‘– : ( ğ‘› + ğ‘— ) ] if | ğ‘£ | = ğ‘› , ğ‘— âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘—
error otherwise
Note that unlike ğ‘£ [ ]  and ğ‘£ [ ğ‘– ] , ğ‘£ [ ğ‘– : ğ‘— ]  may yield a value if ğ‘£  is a string. If w e hav e that ğ‘– , ğ‘— âˆˆ â„•  and
either ğ‘– > ğ‘›  or ğ‘– â‰¥ ğ‘— , then ğ‘£ [ ğ‘– : ğ‘— ]  yields an empty array if ğ‘£  is an array , and an empty string if ğ‘£
is a string.
Example 4.4.2 :  If ğ‘£ = [ 0 , 1 , 2 , 3 ] , then ğ‘£ [ 1 : 3 ] = [ 1 , 2 ] .
The op erator ğ‘£ [ ]  is the only op erator in this subse ction that r eturns a str eam  of value r esults in-
stead of only a value r esult.14 FÃ¤rb er
4.5 UPD A TING
For each access op erator in Se ctionÂ  4.4 , w e will no w deï¬ne an up dating  counterpart. Intuitiv ely ,
wher e an access op erator yields some elements containe d in a value ğ‘£ , its corr esp onding up date
op erator r eplaces  these elements in ğ‘£  by the output of a function. The access op erators will b e use d
in Se ctionÂ 5 , and the up date op erators will b e use d in Se ctionÂ 6 .
All up date op erators take at least a value ğ‘£  and a function ğ‘“  fr om a value to a str eam of value
r esults. W e e xtend the domain of ğ‘“  to value r esults such that ğ‘“ ( ğ‘’ ) = âŸ¨ ğ‘’ âŸ©  if ğ‘’  is an e xception.
The ï¬rst up date op erator will b e a counterpart to ğ‘£ [ ] . For all elements ğ‘¥  that ar e yielde d by ğ‘£ [ ] ,
ğ‘£ [ ] âŠ§ ğ‘“  r eplaces ğ‘¥  by ğ‘“ ( ğ‘¥ ) :
ğ‘£ [ ] âŠ§ ğ‘“ â‰”
â©{{â¨{{â§[ âˆ‘ğ‘–ğ‘“ ( ğ‘£ğ‘– ) ] if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]
â‹ƒğ‘–{{ ğ‘˜ğ‘– : â„ } if ğ‘“ ( ğ‘£ğ‘– ) = âŸ¨ â„ âŸ© + ğ‘¡
{ } otherwiseif ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› }
error otherwise
For an input array ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘£ [ ] âŠ§ ğ‘“  r eplaces each ğ‘£ğ‘–  by the output of ğ‘“ ( ğ‘£ğ‘– ) , yielding
[ ğ‘“ ( ğ‘£0 ) + â€¦ + ğ‘“ ( ğ‘£ğ‘› ) ] . For an input obje ct ğ‘£ = { ğ‘˜0 â†¦ ğ‘£0 , â€¦ , ğ‘˜ğ‘› â†¦ ğ‘£ğ‘› } , ğ‘£ [ ] âŠ§ ğ‘“  r eplaces each ğ‘£ğ‘–
by the ï¬rst output yielde d by ğ‘“ ( ğ‘£ğ‘– )  if such an output e xists, other wise it deletes { ğ‘˜ğ‘– â†¦ ğ‘£ğ‘– }  fr om
the obje ct. Note that up dating arrays div erges fr om jq, b e cause jq only considers the ï¬rst value
yielde d by ğ‘“ .
For the ne xt op erators, w e will use the follo wing function head ( ğ‘™ , ğ‘’ ) , which r eturns the head of
a list ğ‘™  if it is not empty , other wise ğ‘’ :
head ( ğ‘™ , ğ‘’ ) â‰” {â„ if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡
ğ‘’ otherwise
The ne xt function takes a value ğ‘£  and r eplaces its ğ‘– -th element by the ï¬rst output of ğ‘“ , or deletes
it if ğ‘“  yields no output:
ğ‘£ [ ğ‘– ] âŠ§ ğ‘“ â‰”
â©{{{{â¨{{{{â§ğ‘£ [ 0 : ğ‘– ] + [ head ( ğ‘“ ( ğ‘£ [ ğ‘– ] ) , âŸ¨ âŸ© ) ] + ğ‘£ [ ( ğ‘– + 1 ) : ğ‘› ] if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– âˆˆ â„• , and ğ‘– â‰¤ ğ‘›
ğ‘£ [ ğ‘› + ğ‘– ] âŠ§ ğ‘“ if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘–
ğ‘£ + { ğ‘– : â„ } if ğ‘£ = { â€¦ } and ğ‘“ ( ğ‘£ [ ğ‘– ] ) = âŸ¨ â„ âŸ© + ğ‘¡
â‹ƒğ‘˜ âˆˆ dom ( ğ‘£ ) âˆ– { ğ‘– }{ ğ‘˜ â†¦ ğ‘£ [ ğ‘˜ ] } if ğ‘£ = { â€¦ } and ğ‘“ ( ğ‘£ [ ğ‘– ] ) = âŸ¨ âŸ©
error otherwise
Note that this div erges fr om jq if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ]  and ğ‘– > ğ‘› , b e cause jq ï¬lls up the array with null .
The ï¬nal function her e is the up date counterpart of the op erator ğ‘£ [ ğ‘– : ğ‘— ] . It r eplaces the slice
ğ‘£ [ ğ‘– : ğ‘— ]  by the ï¬rst output of ğ‘“  on ğ‘£ [ ğ‘– : ğ‘— ] , or by the empty array if ğ‘“  yields no output.
ğ‘£ [ ğ‘– : ğ‘— ] âŠ§ ğ‘“ â‰”
â©{{{{â¨{{{{â§ğ‘£ [ 0 : ğ‘– ] + head ( ğ‘“ ( ğ‘£ [ ğ‘– : ğ‘— ] ) , [ ] ) + ğ‘£ [ ğ‘— : ğ‘› ] if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– , ğ‘— âˆˆ â„• , and ğ‘– â‰¤ ğ‘—
ğ‘£ if ğ‘£ = [ ğ‘£0 , â€¦ , ğ‘£ğ‘› ] , ğ‘– , ğ‘— âˆˆ â„• , and ğ‘– > ğ‘—
ğ‘£ [ ( ğ‘› + ğ‘– ) : ğ‘— ] âŠ§ ğ‘“ if | ğ‘£ | = ğ‘› , ğ‘– âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘–
ğ‘£ [ ğ‘– : ( ğ‘› + ğ‘— ) ] âŠ§ ğ‘“ if | ğ‘£ | = ğ‘› , ğ‘— âˆˆ â„¤ âˆ– â„• , and 0 â‰¤ ğ‘› + ğ‘—
error otherwise
Unlike its corr esp onding access op erator ğ‘£ [ ğ‘– : ğ‘— ] , this op erator unconditionally fails when ğ‘£  is a
string. This op erator div erges fr om jq if ğ‘“  yields null , in which case jq r eturns an err or , wher eas
this op erator tr eats this as e quivalent to ğ‘“  r eturning [ ] .A formal sp e cification of the jq language 15
Example 4.5.1 :  If ğ‘£ = [ 0 , 1 , 2 , 3 ]  and ğ‘“ ( ğ‘£ ) = [ 4 , 5 , 6 ] , then ğ‘£ [ 1 : 3 ] âŠ§ ğ‘“ = [ 0 , 4 , 5 , 6 , 3 ] .
4.6 ORDERING
In this subse ction, w e establish a total or der on values. â¹
â¹ Note that jq do es not  implement a strict  total or der on values; in particular , its or der on (ï¬‚oating-
p oint) numb ers sp e ciï¬es nan < nan , fr om which follo ws that nan â‰  nan  and nan â‰¯ nan .W e hav e that
null < false < true < ğ‘› < ğ‘  < ğ‘ < ğ‘œ ,
wher e ğ‘›  is a numb er , ğ‘   is a string, ğ‘  is an array , and ğ‘œ  is an obje ct. W e assume that ther e is a total
or der on numb ers and characters. Strings and arrays ar e or der e d le xicographically .
T w o obje cts ğ‘œ1  and ğ‘œ2  ar e or der e d as follo ws: For b oth obje cts ğ‘œğ‘–  ( ğ‘– âˆˆ { 1 , 2 } ), w e sort the array
[ keys ( ğ‘œğ‘– ) ]  by ascending or der to obtain the or der e d array of ke ys ğ‘˜ğ‘– = [ ğ‘˜1 , â€¦ , ğ‘˜ğ‘› ] , fr om which w e
obtain ğ‘£ğ‘– = [ ğ‘œ [ ğ‘˜1 ] , â€¦ , ğ‘œ [ ğ‘˜ğ‘› ] ] . W e then hav e
ğ‘œ1 < ğ‘œ2 âŸº {ğ‘˜1 < ğ‘˜2 if ğ‘˜1 < ğ‘˜2 or ğ‘˜1 > ğ‘˜2
ğ‘£1 < ğ‘£2 otherwise ( ğ‘˜1 = ğ‘˜2 )
5 EV ALU A TION SEMANTICS
In this se ction, w e will deï¬ne a function ğœ‘ |ğ‘
ğ‘£  that r eturns the output of the ï¬lter ğœ‘  in the conte xt
ğ‘  on the input value ğ‘£ .
Let us start with a fe w deï¬nitions. A conte xt  ğ‘  is a mapping fr om variables $ ğ‘¥  to values and fr om
identiï¬ers ğ‘¥  to pairs ( ğ‘“ , ğ‘ ) , wher e ğ‘“  is a ï¬lter and ğ‘  is a conte xt. Conte xts stor e what variables
and ï¬lter arguments ar e b ound to .
W e ar e no w going to intr o duce a fe w help er functions. The ï¬rst function helps deï¬ne ï¬lters
such as if-then-else and alternation ( ğ‘“ â«½ ğ‘” ):
ite ( ğ‘£ , ğ‘– , ğ‘¡ , ğ‘’ ) = {ğ‘¡ if ğ‘£ = ğ‘–
ğ‘’ otherwise
Ne xt, w e deï¬ne a function that is use d to deï¬ne alternation. trues ( ğ‘™ )  r eturns those elements of ğ‘™
whose b o olean values ar e not false . Note that in our conte xt, â€œnot false â€ is not  the same as â€œtrue â€ ,
b e cause the former includes e xceptions, wher eas the latter e xcludes them, and bool ( ğ‘¥ )  can  r eturn
e xceptions, in particular if ğ‘¥  is an e xception.
trues ( ğ‘™ ) â‰” âˆ‘
ğ‘¥ âˆˆ ğ‘™ , bool ( ğ‘¥ ) â‰  falseâŸ¨ ğ‘¥ âŸ©
The e valuation semantics ar e giv en in T ableÂ 5 . Let us discuss its diï¬€er ent cases:
â€¢ â€œ . â€: Returns its input value . This is the identity ï¬lter .
â€¢ ğ‘›  or ğ‘  : Returns the value corr esp onding to the numb er ğ‘›  or string ğ‘  .
â€¢ $ ğ‘¥ : Returns the value curr ently b ound to the variable $ ğ‘¥ , by lo oking it up in the conte xt. W ell-
forme dness of the ï¬lter ( as deï¬ne d in Se ctionÂ 3.1 ) ensur es that such a value always e xists.
â€¢ [ ğ‘“ ] : Cr eates an array fr om the output of ğ‘“ , using the op erator deï¬ne d in Se ctionÂ 4.1 .
â€¢ { } : Cr eates an empty obje ct.
â€¢ { $ ğ‘¥ : $ ğ‘¦ } : Cr eates an obje ct fr om the values b ound to $ ğ‘¥  and $ ğ‘¦ , using the op erator deï¬ne d in
Se ctionÂ 4.1 .
â€¢ ğ‘“ , ğ‘” : Concatenates the outputs of ğ‘“  and ğ‘” .
â€¢ ğ‘“ | ğ‘” : Comp oses ğ‘“  and ğ‘” , r eturning the outputs of ğ‘”  applie d to all outputs of ğ‘“ .16 FÃ¤rb er
ğœ‘ ğœ‘ |ğ‘
ğ‘£
. âŸ¨ ğ‘£ âŸ©
ğ‘› or ğ‘  âŸ¨ ğœ‘ âŸ©
$ ğ‘¥ âŸ¨ ğ‘ ( $ ğ‘¥ ) âŸ©
[ ğ‘“ ] âŸ¨ [ ğ‘“ |ğ‘
ğ‘£ ] âŸ©
{ } âŸ¨ { } âŸ©
{ $ ğ‘¥ : $ ğ‘¦ } âŸ¨ { ğ‘ ( $ ğ‘¥ ) : ğ‘ ( $ ğ‘¦ ) } âŸ©
ğ‘“ , ğ‘” ğ‘“ |ğ‘
ğ‘£ + ğ‘” |ğ‘
ğ‘£
ğ‘“ | ğ‘” âˆ‘ğ‘¥ âˆˆ ğ‘“ |ğ‘ğ‘£ğ‘” |ğ‘
ğ‘¥
ğ‘“ â«½ ğ‘” ite ( trues ( ğ‘“ |ğ‘
ğ‘£ ) , âŸ¨ âŸ© , ğ‘” |ğ‘
ğ‘£ , trues ( ğ‘“ |ğ‘
ğ‘£ ) )
ğ‘“ as $ ğ‘¥ | ğ‘” âˆ‘ğ‘¥ âˆˆ ğ‘“ |ğ‘ğ‘£ğ‘” |ğ‘ { $ ğ‘¥ â†¦ ğ‘¥ }
ğ‘£
$ ğ‘¥ âš¬ $ ğ‘¦ âŸ¨ ğ‘ ( $ ğ‘¥ ) âš¬ ğ‘ ( $ ğ‘¦ ) âŸ©
try ğ‘“ catch ğ‘” âˆ‘ğ‘¥ âˆˆ ğ‘“ |ğ‘ğ‘£{ğ‘” |ğ‘ğ‘’ if ğ‘¥ = error ( ğ‘’ )
âŸ¨ ğ‘¥ âŸ© otherwise
label $ ğ‘¥ | ğ‘“ label ( ğ‘“ |ğ‘
ğ‘£ , $ ğ‘¥ )
break $ ğ‘¥ âŸ¨ break ( $ ğ‘¥ ) âŸ©
$ ğ‘¥ and ğ‘“ junction ( ğ‘ ( $ ğ‘¥ ) , false , ğ‘“ |ğ‘
ğ‘£ )
$ ğ‘¥ or ğ‘“ junction ( ğ‘ ( $ ğ‘¥ ) , true , ğ‘“ |ğ‘
ğ‘£ )
if $ ğ‘¥ then ğ‘“ else ğ‘” ite ( bool ( ğ‘ ( $ ğ‘¥ ) ) , true , ğ‘“ |ğ‘
ğ‘£ , ğ‘” |ğ‘
ğ‘£ )
. [ ] ğ‘£ [ ]
. [ $ ğ‘¥ ] âŸ¨ ğ‘£ [ ğ‘ ( $ ğ‘¥ ) ] âŸ©
. [ $ ğ‘¥ : $ ğ‘¦ ] âŸ¨ ğ‘£ [ ğ‘ ( $ ğ‘¥ ) : ğ‘ ( $ ğ‘¦ ) ] âŸ©
ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) ğœ™ğ‘
ğ‘£ ( ğ‘¥ |ğ‘
ğ‘£ , $ ğ‘¥ , ğ‘“ )
ğ‘¥ ( ğ‘“1 ; â€¦ ; ğ‘“ğ‘› ) ğ‘“ |ğ‘ âˆª â‹ƒğ‘–{ ğ‘¥ğ‘– â†¦ ( ğ‘“ğ‘– , ğ‘ ) }
ğ‘£ if ğ‘¥ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğ‘“
ğ‘¥ ğ‘“ |ğ‘â€²
ğ‘£ if ğ‘ ( ğ‘¥ ) = ( ğ‘“ , ğ‘â€²)
ğ‘“ âŠ§ ğ‘” se e Se ctionÂ 6
T ableÂ 5: Evaluation semantics.A formal sp e cification of the jq language 17
â€¢ ğ‘“ â«½ ğ‘” : Returns ğ‘™  if ğ‘™  is not empty , else the outputs of ğ‘” , wher e ğ‘™  ar e the outputs of ğ‘“  whose
b o olean values ar e not false .
â€¢ ğ‘“ as $ ğ‘¥ | ğ‘” : For e v er y output of ğ‘“ , binds it to the variable $ ğ‘¥  and r eturns the output of ğ‘” , wher e
ğ‘”  may r efer ence $ ğ‘¥ . Unlike ğ‘“ | ğ‘” , this runs ğ‘”  with the original input value instead of an output
of ğ‘“ . W e can sho w that the e valuation of ğ‘“ | ğ‘”  is e quivalent to that of ğ‘“ as $ ğ‘¥â€²| $ ğ‘¥â€²| ğ‘” , wher e
$ ğ‘¥â€² is a fr esh variable . Ther efor e , w e could b e tempte d to lo w er ğ‘“ | ğ‘”  to âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| $ ğ‘¥â€²| âŒŠ ğ‘” âŒ‹
in T ableÂ  2 . Ho w e v er , w e cannot do this b e cause w e will se e in Se ctionÂ  6  that this e quivalence
do es not  hold for up dates; that is, ( ğ‘“ | ğ‘” ) âŠ§ ğœ  is not  e qual to ( ğ‘“ as $ ğ‘¥â€²| $ ğ‘¥â€²| ğ‘” ) âŠ§ ğœ .
â€¢ $ ğ‘¥ âš¬ $ ğ‘¦ : Returns the output of a Cartesian op eration â€œ âš¬ â€ ( any of â‰Ÿ , â‰  , < , â‰¤ , > , â‰¥ , + , âˆ’ , Ã— , Ã· ,
and % , as giv en in T ableÂ  1 ) on the values b ound to $ ğ‘¥  and $ ğ‘¦ . The semantics of the arithmetic
op erators ar e giv en in Se ctionÂ  4.3 , the comparison op erators ar e deï¬ne d by the or dering giv en
in Se ctionÂ 4.6 , ğ‘™ â‰Ÿ ğ‘Ÿ  r eturns whether ğ‘™  e quals ğ‘Ÿ , and ğ‘™ â‰  ğ‘Ÿ  r eturns its negation.
â€¢ try ğ‘“ catch ğ‘” : Replaces all outputs of ğ‘“  that e qual error ( ğ‘’ )  for some ğ‘’  by the output of ğ‘”
on the input ğ‘’ . Note that this div erges fr om jq, which ab orts the e valuation of ğ‘“  after the
ï¬rst err or . This b ehaviour can b e simulate d in our semantics, by r eplacing try ğ‘“ catch ğ‘”  with
label $ ğ‘¥â€²| try ğ‘“ catch ( ğ‘” , break $ ğ‘¥â€²) .
â€¢ label $ ğ‘¥ | ğ‘“ : Returns all values yielde d by ğ‘“  until ğ‘“  yields an e xception break ( $ ğ‘¥ ) . This uses the
function label ( ğ‘™ , $ ğ‘¥ ) , which r eturns all elements of ğ‘™  until the curr ent element is an e xception
of the form break ( $ ğ‘¥ ) :
label ( ğ‘™ , $ ğ‘¥ ) â‰” {âŸ¨ â„ âŸ© + label ( ğ‘¡ , $ ğ‘¥ ) if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡ and â„ â‰  break ( $ ğ‘¥ )
âŸ¨ âŸ© otherwise
â€¢ break $ ğ‘¥ : Returns a value break ( $ ğ‘¥ ) . Similarly to the e valuation of variables $ ğ‘¥  describ e d
ab o v e , w ellforme dness of the ï¬lter ( as deï¬ne d in Se ctionÂ  3.1 ) ensur es that the r eturne d value
break ( $ ğ‘¥ )  will b e e v entually handle d by a corr esp onding ï¬lter label $ ğ‘¥ | ğ‘“ . That means that
the e valuation of a w ellforme d ï¬lter can only yield values and err ors, but ne v er break ( $ ğ‘¥ ) .
â€¢ $ ğ‘¥ and ğ‘“ : Returns false if $ ğ‘¥  is b ound to either null or false , else r eturns the output of ğ‘“  mapp e d
to b o olean values. This uses the function junction ( ğ‘¥ , ğ‘£ , ğ‘™ ) , which r eturns just ğ‘£  if the b o olean
value of ğ‘¥  is ğ‘£  ( wher e ğ‘£  will b e true or false), other wise the b o olean values of the values in ğ‘™ .
Her e , bool ( ğ‘£ )  r eturns the b o olean value as giv en in Se ctionÂ 4.2 .
junction ( ğ‘¥ , ğ‘£ , ğ‘™ ) â‰” ite ( bool ( ğ‘¥ ) , ğ‘£ , âŸ¨ ğ‘£ âŸ© , âˆ‘
ğ‘¦ âˆˆ ğ‘™âŸ¨ bool ( ğ‘¦ ) âŸ© )
â€¢ $ ğ‘¥ or ğ‘“ : Similar to its â€œandâ€ counterpart ab o v e .
â€¢ if $ ğ‘¥ then ğ‘“ else ğ‘” : Returns the output of ğ‘“  if $ ğ‘¥  is b ound to either null or false , else r eturns
the output of ğ‘” .
â€¢ . [ ] , . [ $ ğ‘¥ ] , or . [ $ ğ‘¥ : $ ğ‘¦ ] : A ccesses parts of the input value; se e Se ctionÂ  4.4  for the deï¬nitions of the
op erators.
â€¢ ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) : Folds ğ‘“  o v er the values r eturne d by ğ‘¥ , starting with the curr ent input as accu-
mulator . The curr ent accumulator value is pr o vide d to ğ‘“  as input value and ğ‘“  can access the
curr ent value of ğ‘¥  by $ ğ‘¥ . If ğœ™ = reduce , this r eturns only the ï¬nal values of the accumulator ,
wher eas if ğœ™ = foreach , this r eturns also the interme diate values of the accumulator . W e will
deï¬ne the functions reduceğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ )  and foreachğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ )  in Se ctionÂ 5.1 .
â€¢ ğ‘¥ ( ğ‘“1 ; â€¦ ; ğ‘“ğ‘› ) : Calls an ğ‘› -ar y ï¬lter ğ‘¥  that is deï¬ne d by ğ‘¥ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğ‘“ . The output is that of
the ï¬lter ğ‘“ , wher e each ï¬lter argument ğ‘¥ğ‘–  is b ound to ( ğ‘“ğ‘– , ğ‘ ) . This also handles the case of calling
nullar y ï¬lters such as empty .
â€¢ ğ‘¥ : Calls a ï¬lter argument. By the w ell-forme dness r e quir ements giv en in Se ctionÂ  3.1 , this must
o ccur within the right-hand side of a deï¬nition whose arguments include ğ‘¥ . This r e quir ement18 FÃ¤rb er
also ensur es that ğ‘¥ âˆˆ dom ( ğ‘ ) , b e cause an ğ‘¥  can only b e e valuate d as part of a call to the ï¬lter
wher e it was b ound, and by the semantics of ï¬lter calls ab o v e , this adds a binding for ğ‘¥  to the
conte xt.
â€¢ ğ‘“ âŠ§ ğ‘” : Up dates the input at p ositions r eturne d by ğ‘“  by ğ‘” . W e will discuss this in Se ctionÂ 6 .
An implementation may also deï¬ne custom semantics for name d ï¬lters. For e xample , an imple-
mentation may deï¬ne error |ğ‘
ğ‘£ â‰” error ( ğ‘£ ) , keys |ğ‘
ğ‘£ â‰” keys ( ğ‘£ ) , and length |ğ‘
ğ‘£ â‰” | ğ‘£ | , se e Se ctionÂ  4.2 .
In the case of keys , for e xample , ther e is no obvious way to implement it by deï¬nition, in par-
ticular b e cause ther e is no simple way to obtain the domain of an obje ct { â€¦ }  using only the
ï¬lters for which w e gav e semantics in T ableÂ  5 . For length , w e could giv e a deï¬nition, using
reduce . [ ] as $ ğ‘¥ ( 0 ; . + 1 )  to obtain the length of arrays and obje cts, but this w ould inher ently
r e quir e linear time to yield a r esult, instead of constant time that can b e achie v e d by a pr op er jq
implementation.
5.1 FOLDING
In this subse ction, w e will deï¬ne the functions ğœ™ğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ )  ( wher e ğœ™  is either foreach  or reduce ),
which underlie the semantics for the folding op erators ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) .
Let us start by deï¬ning a general folding function foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğ‘œ ) : It takes a str eam of value
r esults ğ‘™ , a variable $ ğ‘¥ , a ï¬lter ğ‘“ , and a function ğ‘œ ( ğ‘¥ )  fr om a value ğ‘¥  to a str eam of values. This
function folds o v er the elements in ğ‘™ , starting fr om the accumulator value ğ‘£ . It yields the ne xt
accumulator value( s) by e valuating ğ‘“  with the curr ent accumulator value as input and with the
variable $ ğ‘¥  b ound to the ï¬rst element in ğ‘™ . If ğ‘™  is empty , then ğ‘£  is calle d a ï¬nal  accumulator value
and is r eturne d, other wise ğ‘£  is calle d an interme diate  accumulator value and ğ‘œ ( ğ‘£ )  is r eturne d.
foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğ‘œ ) â‰”
â©{â¨{â§ ğ‘œ ( ğ‘£ ) + âˆ‘ğ‘¥ âˆˆ ğ‘“ |ğ‘ { $ ğ‘¥ â†¦ â„ }
ğ‘£foldğ‘ğ‘¥ ( ğ‘¡ , $ ğ‘¥ , ğ‘“ , ğ‘œ ) if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡
âŸ¨ ğ‘£ âŸ© otherwise ( ğ‘™ = âŸ¨ âŸ© )
W e use tw o diï¬€er ent functions for ğ‘œ ( ğ‘£ ) ; the ï¬rst r eturns nothing, corr esp onding to reduce  which
do es not r eturn interme diate values, and the other r eturns just ğ‘£ , corr esp onding to foreach  which
r eturns interme diate values. Instantiating fold  with these tw o functions, w e obtain the follo wing:
reduceğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) â‰” foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğ‘œ ) where ğ‘œ ( ğ‘£ ) = âŸ¨ âŸ©
forğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) â‰” foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğ‘œ ) where ğ‘œ ( ğ‘£ ) = âŸ¨ ğ‘£ âŸ©
Her e , reduceğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ )  is the function that is use d in T ableÂ  5 . Ho w e v er , forğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ )  do es not  im-
plement the semantics of foreach , b e cause it yields the initial accumulator value , wher eas foreach
omits it.
Example 5.1.1 :  If w e w ould set foreachğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) â‰” forğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) , then e valuating
foreach ( 1 , 2 , 3 ) as $ ğ‘¥ ( 0 ; . + $ ğ‘¥ )  w ould yield âŸ¨ 0 , 1 , 3 , 6 âŸ© , but jq e valuates it to âŸ¨ 1 , 3 , 6 âŸ© .
For that r eason, w e deï¬ne foreach  in terms of for , but with a sp e cial tr eatment for the initial ac-
cumulator:
foreachğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) â‰”
â©{â¨{â§ âˆ‘ğ‘¥ âˆˆ ğ‘“ |ğ‘ { $ ğ‘¥ â†¦ â„ }
ğ‘£forğ‘ğ‘¥ ( ğ‘¡ , $ ğ‘¥ , ğ‘“ ) if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡
âŸ¨ âŸ© otherwise
W e will no w lo ok at what the e valuation of the various folding ï¬lters e xpands to . Apart fr om
reduce  and foreach , w e will also consider a hyp othetical ï¬lter for ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ )  that is deï¬ne d by
the function forğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ ) , analogously to the other folding ï¬lters.
A ssuming that the ï¬lter ğ‘¥  e valuates to âŸ¨ ğ‘¥0 , â€¦ , ğ‘¥ğ‘› âŸ© , then reduce  and for  e xpand toA formal sp e cification of the jq language 19
reduce ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) = ğ‘¥0 as $ ğ‘¥ | ğ‘“ for ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) = . , ( ğ‘¥0 as $ ğ‘¥ | ğ‘“
| â€¦ | â€¦
| ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ | . , ( ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ ) â€¦ )
and foreach  e xpands to
foreach ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) = ğ‘¥0 as $ ğ‘¥ | ğ‘“
| . , ( ğ‘¥1 as $ ğ‘¥ | ğ‘“
| â€¦
| . , ( ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ ) â€¦ ) .
W e can se e that the sp e cial tr eatment of the initial accumulator value also sho ws up in the e xpan-
sion of foreach . In contrast, the hyp othetical for  ï¬lter lo oks mor e symmetrical to reduce .
Note that jq implements only a r estricte d v ersion of these folding op erators that discar ds all
output values of ğ‘“  after the ï¬rst output. That means that in jq, ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ )  is e quivalent to
ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; first ( ğ‘“ ) ) . Her e , w e assume the deï¬nition first ( ğ‘“ ) â‰” label $ ğ‘¥ | ğ‘“ | ( . , break $ ğ‘¥ ) . This
r eturns the ï¬rst output of ğ‘“  if ğ‘“  yields any output, else nothing.
6 UPD A TE SEMANTICS
In this se ction, w e will discuss ho w to e valuate up dates ğ‘“ âŠ§ ğ‘” . First, w e will sho w ho w the original
jq implementation e xe cutes such up dates, and sho w which pr oblems this appr oach entails. Then,
w e will giv e alternativ e semantics for up dates that av oids these pr oblems, while enabling faster
p erformance by forgoing the construction of temp orar y path data.
6.1 JQ UPD A TES VIA P A THS
jqâ€™s up date me chanism w orks with paths . A path is a se quence of indices ğ‘–ğ‘—  that can b e written as
. [ ğ‘–1 ] â€¦ [ ğ‘–ğ‘› ] . It r efers to a value that can b e r etrie v e d by the ï¬lter â€œ . [ ğ‘–1 ] | â€¦ | . [ ğ‘–ğ‘› ] â€ . Note that â€œ . â€ is
a valid path, r eferring to the input value .
The up date op eration â€œ ğ‘“ âŠ§ ğ‘” â€ attempts to ï¬rst obtain the paths of all values r eturne d by ğ‘“ , then
for each path, it r eplaces the value at the path by ğ‘”  applie d to it. Note that ğ‘“  is not allo w e d to
pr o duce ne w values; it may only r eturn paths.
Example 6.1.1 :  Consider the input value [ [ 1 , 2 ] , [ 3 , 4 ] ] . W e can r etrie v e the arrays [ 1 , 2 ]  and [ 3 , 4 ]
fr om the input with the ï¬lter â€œ . [ ] â€ , and w e can r etrie v e the numb ers 1, 2, 3, 4 fr om the input with
the ï¬lter â€œ . [ ] | . [ ] â€ . T o r eplace each numb er with its successor , w e run â€œ ( . [ ] | . [ ] ) âŠ§ . + 1 â€ , obtaining
[ [ 2 , 3 ] , [ 4 , 5 ] ] . Internally , in jq, this ï¬rst builds the paths . [ 0 ] [ 0 ] , . [ 0 ] [ 1 ] , . [ 1 ] [ 0 ] , . [ 1 ] [ 1 ] , then up dates
the value at each of these paths with ğ‘” .
This appr oach can yield surprising r esults when the e xe cution of the ï¬lter ğ‘”  changes the input
value in a way that the set of paths changes midway . In such cases, only the paths constructe d
fr om the initial input ar e consider e d. This can lead to paths p ointing to the wr ong data, paths
p ointing to non-e xistent data, and missing paths.
Example 6.1.2 :  Consider the input value { " ğ‘ " â†¦ { " ğ‘ " â†¦ 1 } }  and the ï¬lter ( . [ ] , . [ ] [ ] ) âŠ§ ğ‘” , wher e
ğ‘”  is [ ] . Exe cuting this ï¬lter in jq ï¬rst builds the path . [ " ğ‘ " ]  stemming fr om â€œ . [ ] â€ , then . [ " ğ‘ " ] [ " ğ‘ " ]
stemming fr om â€œ . [ ] [ ] â€ . Ne xt, jq folds o v er the paths, using the input value as initial accumula-
tor and up dating the accumulator at each path with ğ‘” . The ï¬nal output is thus the output of
( . [ " ğ‘ " ] âŠ§ ğ‘” ) | ( . [ " ğ‘ " ] [ " ğ‘ " ] âŠ§ ğ‘” ) . The output of the ï¬rst step . [ " ğ‘ " ] âŠ§ ğ‘”  is { " ğ‘ " â†¦ [ ] } . This value is the
input to the se cond step . [ " ğ‘ " ] [ " ğ‘ " ] âŠ§ ğ‘” , which yields an err or b e cause w e cannot inde x the array
[ ]  at the path . [ " ğ‘ " ]  by . [ " ğ‘ " ] .20 FÃ¤rb er
W e can also hav e surprising b ehaviour that do es not manifest any err or .
Example 6.1.3 :  Consider the same input value and ï¬lter as in ExampleÂ  6.1.2 , but no w with ğ‘”  set to
{ " ğ‘ " : 2 } . The output of the ï¬rst step . [ " ğ‘ " ] âŠ§ ğ‘”  is { " ğ‘ " â†¦ { " ğ‘ " â†¦ 2 } } . This value is the input to the
se cond step . [ " ğ‘ " ] [ " ğ‘ " ] âŠ§ ğ‘” , which yields { " ğ‘ " â†¦ { " ğ‘ " â†¦ 2 , " ğ‘ " â†¦ { " ğ‘ " â†¦ 2 } } } . Her e , the r emain-
ing path ( . [ " ğ‘ " ] [ " ğ‘ " ] ) p ointe d to data that was r emo v e d by the up date on the ï¬rst path, so this data
gets r eintr o duce d by the up date . On the other hand, the data intr o duce d by the ï¬rst up date step
( at the path . [ " ğ‘ " ] [ " ğ‘ " ] ) is not part of the original path, so it is not  up date d.
W e found that w e can interpr et many up date ï¬lters by simpler ï¬lters, yielding the same output
as jq in most common cases, but av oiding the pr oblems sho wn ab o v e . T o se e this, let us se e what
w ould happ en if w e w ould interpr et ( ğ‘“1 , ğ‘“2 ) âŠ§ ğ‘”  as ( ğ‘“1 âŠ§ ğ‘” ) | ( ğ‘“2 âŠ§ ğ‘” ) . That way , the paths of ğ‘“2
w ould p oint pr e cisely to the data r eturne d by ğ‘“1 âŠ§ ğ‘” , thus av oiding the pr oblems depicte d by the
e xamples ab o v e . In particular , with such an appr oach, ExampleÂ  6.1.2  w ould yield { " ğ‘ " â†¦ [ ] }  in-
stead of an err or , and ExampleÂ 6.1.3  w ould yield { " ğ‘ " â†¦ { " ğ‘ " â†¦ { " ğ‘ " â†¦ 2 } } } .
In the r emainder of this se ction, w e will sho w semantics that e xtend this idea to all up date op-
erations. The r esulting up date semantics can b e understo o d to interleav e  calls to ğ‘“  and ğ‘” . By doing
so , these semantics can abandon the construction of paths altogether , which r esults in higher p er-
formance when e valuating up dates.
6.2 PROPERTIES OF NEW SEMANTICS
ğœ‡ ğœ‡ âŠ§ ğœ
empty ( ) .
. ğœ
ğ‘“ | ğ‘” ğ‘“ âŠ§ ( ğ‘” âŠ§ ğœ )
ğ‘“ , ğ‘” ( ğ‘“ âŠ§ ğœ ) | ( ğ‘” âŠ§ ğœ )
if $ ğ‘¥ then ğ‘“ else ğ‘” if $ ğ‘¥ then ğ‘“ âŠ§ ğœ else ğ‘” âŠ§ ğœ
ğ‘“ â«½ ğ‘” if first ( ğ‘“ â«½ null ) then ğ‘“ âŠ§ ğœ else ğ‘” âŠ§ ğœ
T ableÂ 6: Up date semantics pr op erties.T ableÂ  6  giv es a fe w pr op erties that w e want to hold for up dates ğœ‡ âŠ§ ğœ . Let us discuss these for the
diï¬€er ent ï¬lters ğœ‡ :
â€¢ empty ( ) : Returns the input unchange d.
â€¢ â€œ . â€: Returns the output of the up date ï¬lter ğœ  applie d to the curr ent input. Note that while jq only
r eturns at most one output of ğœ , these semantics r eturn an arbitrar y numb er of outputs.
â€¢ ğ‘“ | ğ‘” : Up dates at ğ‘“  with the up date of ğœ  at ğ‘” . This allo ws us to interpr et ( . [ ] | . [ ] ) âŠ§ ğœ  in
ExampleÂ 6.1.1  by . [ ] âŠ§ ( . [ ] âŠ§ ğœ ) , yielding the same output as in the e xample .
â€¢ ğ‘“ , ğ‘” : Applies the up date of ğœ  at ğ‘”  to the output of the up date of ğœ  at ğ‘“ . W e hav e alr eady se en
this at the end of Se ctionÂ 6.1 .
â€¢ if $ ğ‘¥ then ğ‘“ else ğ‘” : Applies ğœ  at ğ‘“  if $ ğ‘¥  holds, else at ğ‘” .
â€¢ ğ‘“ â«½ ğ‘” : Applies ğœ  at ğ‘“  if ğ‘“  yields some output whose b o olean value ( se e Se ctionÂ  4.2 ) is not false ,
else applies ğœ  at ğ‘” . Se e Se ctionÂ 5.1  for the deï¬nition of first .
While T ableÂ  6  allo ws us to deï¬ne the b ehaviour of se v eral ï¬lters by r e ducing them to mor e prim-
itiv e ï¬lters, ther e ar e se v eral ï¬lters ğœ‡  which cannot b e deï¬ne d this way . W e will ther efor e giv eA formal sp e cification of the jq language 21
the actual up date semantics of ğœ‡ âŠ§ ğœ  in Se ctionÂ  6.4  by deï¬ning ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£ , not by translating ğœ‡ âŠ§ ğœ
to e quivalent ï¬lters.
6.3 LIMITING INTERA CTIONS
T o deï¬ne ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£ , w e ï¬rst hav e to understand ho w to pr e v ent unwante d interactions b etw e en
ğœ‡  and ğœ . In particular , w e hav e to lo ok at variable bindings and err or catching.
6.3.1 V ARIABLE BINDINGS
W e can bind variables in ğœ‡ ; that is, ğœ‡  can hav e the shap e ğ‘“ as $ ğ‘¥ | ğ‘” . Her e , the intent is that ğ‘”
has access to $ ğ‘¥ , wher eas ğœ  do es not! This is to ensur e compatibility with jqâ€™s original semantics,
which e xe cute ğœ‡  and ğœ  indep endently , so ğœ  should not b e able to access variables b ound in ğœ‡ .
Example 6.3.1.1 :  Consider the ï¬lter 0 as $ ğ‘¥ | ğœ‡ âŠ§ ğœ , wher e ğœ‡  is ( 1 as $ ğ‘¥ | . [ $ ğ‘¥ ] )  and ğœ  is $ ğ‘¥ . This
up dates the input array at inde x 1 . If ğœ  had access to variables b ound in ğœ‡ , then the array element
w ould b e r eplace d by 1 , b e cause the variable binding 0 as $ ğ‘¥  w ould b e shado w e d by 1 as $ ğ‘¥ .
Ho w e v er , in jq, ğœ  do es not hav e access to variables b ound in ğœ‡ , so the array element is r eplace d
by 0 , which is the value originally b ound to $ ğ‘¥ . Giv en the input array [ 1 , 2 , 3 ] , the ï¬lter yields the
ï¬nal r esult [ 1 , 0 , 3 ] .
W e take the follo wing appr oach to pr e v ent variables b ound in ğœ‡  to â€œleakâ€ into ğœ : When e valuating
( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£ , w e want ğœ  to always b e e xe cute d with the same ğ‘ . That is, e valuating ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£  should
ne v er e valuate ğœ  with any conte xt other than ğ‘ . In or der to ensur e that, w e will deï¬ne ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£
not for a ï¬lter  ğœ , but for a function  ğœ ( ğ‘¥ ) , wher e ğœ ( ğ‘¥ )  r eturns the output of the ï¬lter ğœ |ğ‘
ğ‘¥ . This allo ws
us to e xtend the conte xt ğ‘  with bindings on the left-hand side of the up date , while e xe cuting the
up date ï¬lter ğœ  always with the same original conte xt ğ‘ .
6.3.2 ERROR CA T CHING
W e can catch err ors in ğœ‡ ; that is, ğœ‡  can hav e the shap e try ğ‘“ catch ğ‘” . Ho w e v er , this should catch
only err ors that o ccur in ğœ‡ , not  err ors that ar e r eturne d by ğœ .
Example 6.3.2.1 :  Consider the ï¬lter ğœ‡ âŠ§ ğœ , wher e ğœ‡  is . [ ] ?  and ğœ  is . + 1 . The ï¬lter ğœ‡  is lo w er e d
to the MIR ï¬lter try . [ ] catch empty ( ) . The intention of ğœ‡ âŠ§ ğœ  is to up date all elements . [ ]  of the
input value , and if . [ ]  r eturns an err or ( which o ccurs when the input is neither an array nor an
obje ct, se e Se ctionÂ  4.4 ), to just r eturn the input value unchange d. When w e run ğœ‡ âŠ§ ğœ  with the
input 0 , the ï¬lter . [ ]  fails with an err or , but b e cause the err or is caught imme diately after war ds,
ğœ‡ âŠ§ ğœ  conse quently just r eturns the original input value 0 . The inter esting part is what happ ens
when ğœ  thr o ws an err or: This o ccurs for e xample when running the ï¬lter with the input [ { } ] . This
w ould run . + 1  with the input { } , which yields an err or ( se e Se ctionÂ  4.3 ). This err or is  r eturne d
by ğœ‡ âŠ§ ğœ .
This raises the question: Ho w can w e e xe cute ( try ğ‘“ catch ğ‘” ) âŠ§ ğœ  and distinguish err ors stem-
ming fr om ğ‘“  fr om err ors stemming fr om ğœ ?
W e came up with the solution of p olarise d e xceptions . In a nutshell, w e want e v er y e xception
that is r eturne d by ğœ  to b e marke d in a sp e cial way such that it can b e ignor e d by a tr y-catch
in ğœ‡ . For this, w e assume the e xistence of tw o functions polarise ( ğ‘¥ )  and depolarise ( ğ‘¥ )  fr om a
value r esult ğ‘¥  to a value r esult. If ğ‘¥  is an e xception, then polarise ( ğ‘¥ )  should r eturn a p olarise d v er-
sion of it, wher eas depolarise ( ğ‘¥ )  should r eturn an unp olarise d v ersion of it, i.e . it should r emo v e
any p olarisation fr om an e xception. Ev er y e xception cr eate d by error ( ğ‘’ )  is unp olarise d. With this
metho d, when w e e valuate an e xpr ession try ğ‘“ catch ğ‘”  in ğœ‡ , w e can analyse the output of ğ‘“ âŠ§ ğœ ,22 FÃ¤rb er
and only catch unp olarise d  err ors. That way , err ors stemming fr om ğœ‡  ar e pr opagate d, wher eas
err ors stemming fr om ğ‘“  ar e caught.
6.4 NEW SEMANTICS
W e will no w giv e semantics that deï¬ne the output of ( ğ‘“ âŠ§ ğ‘” ) |ğ‘
ğ‘£  as r eferr e d to in Se ctionÂ 5 .
W e will ï¬rst combine the te chniques in Se ctionÂ  6.3  to deï¬ne ( ğ‘“ âŠ§ ğ‘” ) |ğ‘
ğ‘£  for tw o ï¬lters  ğ‘“  and ğ‘”  by
( ğ‘“ âŠ§ ğœ ) |ğ‘
ğ‘£ , wher e ğœ  no w is a function  fr om a value to a str eam of value r esults:
( ğ‘“ âŠ§ ğ‘” ) |ğ‘
ğ‘£ â‰” âˆ‘
ğ‘¦ âˆˆ ( ğ‘“ âŠ§ ğœ ) |ğ‘ğ‘£depolarise ( ğ‘¦ ) , where ğœ ( ğ‘¥ ) = âˆ‘
ğ‘¦ âˆˆ ğ‘” |ğ‘ğ‘¥polarise ( ğ‘¦ ) .
W e use a function instead of a ï¬lter on the right-hand side to limit the scop e of variable bindings
as e xplaine d in Se ctionÂ  6.3.1 , and w e use polarise  to r estrict the scop e of caught e xceptions, as
discusse d in Se ctionÂ  6.3.2 . Note that w e depolarise  the ï¬nal outputs of ğ‘“ âŠ§ ğ‘”  in or der to pr e v ent
leaking p olarisation information outside the up date .
ğœ‡ ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£
. ğœ ( ğ‘£ )
ğ‘“ | ğ‘” ( ğ‘“ âŠ§ ğœâ€²) |ğ‘
ğ‘£ where ğœâ€²( ğ‘¥ ) = ( ğ‘” âŠ§ ğœ ) |ğ‘
ğ‘¥
ğ‘“ , ğ‘” âˆ‘ğ‘¥ âˆˆ ( ğ‘“ âŠ§ ğœ ) |ğ‘ğ‘£( ğ‘” âŠ§ ğœ ) |ğ‘
ğ‘¥
ğ‘“ â«½ ğ‘” ite ( trues ( ğ‘“ |ğ‘
ğ‘£ ) , âŸ¨ âŸ© , ( ğ‘” âŠ§ ğœ ) |ğ‘
ğ‘£ , ( ğ‘“ âŠ§ ğœ ) |ğ‘
ğ‘£ )
. [ ] âŸ¨ ğ‘£ [ ] âŠ§ ğœ ( ğ‘£ ) âŸ©
. [ $ ğ‘¥ ] âŸ¨ ğ‘£ [ ğ‘ ( $ ğ‘¥ ) ] âŠ§ ğœ ( ğ‘£ ) âŸ©
. [ $ ğ‘¥ : $ ğ‘¦ ] âŸ¨ ğ‘£ [ ğ‘ ( $ ğ‘¥ ) : ğ‘ ( $ ğ‘¦ ) ] âŠ§ ğœ ( ğ‘£ ) âŸ©
ğ‘“ as $ ğ‘¥ | ğ‘” reduceğ‘
ğ‘£ ( ğ‘“ |ğ‘
ğ‘£ , $ ğ‘¥ , ( ğ‘” âŠ§ ğœ ) )
if $ ğ‘¥ then ğ‘“ else ğ‘” ite ( ğ‘ ( $ ğ‘¥ ) , true , ( ğ‘“ âŠ§ ğœ ) |ğ‘
ğ‘£ , ( ğ‘” âŠ§ ğœ ) |ğ‘
ğ‘£ )
try ğ‘“ catch ğ‘” âˆ‘ğ‘¥ âˆˆ ( ğ‘“ âŠ§ ğœ ) |ğ‘ğ‘£catch ( ğ‘¥ , ğ‘” , ğ‘ , ğ‘£ )
break $ ğ‘¥ âŸ¨ break ( $ ğ‘¥ ) âŸ©
ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) ğœ™ğ‘
ğ‘£ ( ğ‘¥ |ğ‘
ğ‘£ , $ ğ‘¥ , ğ‘“ , ğœ )
ğ‘¥ ( ğ‘“1 ; â€¦ ; ğ‘“ğ‘› ) ( ğ‘“ âŠ§ ğœ ) |ğ‘ âˆª â‹ƒğ‘–{ ğ‘¥ğ‘– â†¦ ( ğ‘“ğ‘– , ğ‘ ) }
ğ‘£ if ğ‘¥ ( ğ‘¥1 ; â€¦ ; ğ‘¥ğ‘› ) â‰” ğ‘“
ğ‘¥ ( ğ‘“ âŠ§ ğœ ) |ğ‘â€²
ğ‘£ if ğ‘ ( ğ‘¥ ) = ( ğ‘“ , ğ‘â€²)
T ableÂ 7: Up date semantics. Her e , ğœ‡  is a ï¬lter and ğœ ( ğ‘£ )  is a function fr om a value ğ‘£  to a str eam of
value r esults.T ableÂ  7  sho ws the deï¬nition of ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£ . Se v eral of the cases for ğœ‡ , like â€œ . â€ , â€œ ğ‘“ | ğ‘” â€ , â€œ ğ‘“ , ğ‘” â€ ,
and â€œ if $ ğ‘¥ then ğ‘“ else ğ‘” â€ ar e simply r elativ ely straightfor war d conse quences of the pr op erties in
T ableÂ 6 . W e discuss the r emaining cases for ğœ‡ :
â€¢ ğ‘“ â«½ ğ‘” : Up dates using ğ‘“  if ğ‘“  yields some non-false value , else up dates using ğ‘” . Her e , ğ‘“  is calle d
as a â€œpr ob e â€ ï¬rst. If it yields at least one output that is consider e d â€œtrue â€ ( se e Se ctionÂ  5  for the
deï¬nition of trues ), then w e up date at ğ‘“ , else at ğ‘” . This ï¬lter is unusual b e cause is the only kind
wher e a sub e xpr ession is b oth up date d with ( ( ğ‘“ âŠ§ ğœ ) |ğ‘
ğ‘£ ) and e valuate d ( ğ‘“ |ğ‘
ğ‘£ ).
â€¢ . [ ] , . [ $ ğ‘¥ ] , . [ $ ğ‘¥ : $ ğ‘¦ ] : Applies ğœ  to the curr ent value using the op erators deï¬ne d in Se ctionÂ 4.5 .A formal sp e cification of the jq language 23
â€¢ ğ‘“ as $ ğ‘¥ | ğ‘” : Folds o v er all outputs of ğ‘“ , using the input value ğ‘£  as initial accumulator and up-
dating the accumulator by ğ‘” âŠ§ ğœ , wher e $ ğ‘¥  is b ound to the curr ent output of ğ‘“ . The deï¬nition
of reduce  is giv en in Se ctionÂ 5.1 .
â€¢ try ğ‘“ catch ğ‘” : Returns the output of ğ‘“ âŠ§ ğœ , mapping err ors o ccurring in ğ‘“  to ğ‘” . The deï¬nition
of the function catch  is
catch ( ğ‘¥ , ğ‘” , ğ‘ , ğ‘£ ) â‰”
â©{{â¨{{â§ âˆ‘ğ‘¦ âˆˆ ğ‘” |ğ‘ğ‘’âŸ¨ error ( ğ‘¦ ) âŸ© if ğ‘¥ = error ( ğ‘’ ) , ğ‘¥ is unpolarised, and ğ‘” |ğ‘ğ‘¥ â‰  âŸ¨ âŸ©
âŸ¨ ğ‘£ âŸ© if ğ‘¥ = error ( ğ‘’ ) , ğ‘¥ is unpolarised, and ğ‘” |ğ‘ğ‘¥ = âŸ¨ âŸ©
âŸ¨ ğ‘¥ âŸ© otherwise
The function catch ( ğ‘¥ , ğ‘” , ğ‘ , ğ‘£ )  analyses ğ‘¥  (the curr ent output of ğ‘“ ): If ğ‘¥  is no unp olarise d err or , ğ‘¥
is r eturne d. For e xample , that is the case if the original right-hand side of the up date r eturns an
err or , in which case w e do not want this err or to b e caught her e . Ho w e v er , if ğ‘¥  is an unp olarise d
err or , that is, an err or that was cause d on the left-hand side of the up date , it has to b e caught
her e . In that case , catch  analyses the output of ğ‘”  with input ğ‘¥ : If ğ‘”  yields no output, then it
r eturns the original input value ğ‘£ , and if ğ‘”  yields output, all its output is mapp e d to err ors! This
b ehaviour might se em p e culiar , but it makes sense when w e consider the jq way of implement-
ing up dates via paths: When e valuating some up date ğœ‡ âŠ§ ğœ  with an input value ğ‘£ , the ï¬lter ğœ‡
may only r eturn paths to data containe d within ğ‘£ . When ğœ‡  is try ğ‘“ catch ğ‘” , the ï¬lter ğ‘”  only
r e ceiv es inputs that stem fr om err ors, and b e cause ğ‘£  cannot contain err ors, these inputs cannot
b e containe d in ğ‘£ . Conse quentially , ğ‘”  can ne v er r eturn any path p ointing to ğ‘£ . The only way ,
ther efor e , to get out aliv e fr om a catch  is for ğ‘”  to r eturn â€¦ nothing.
â€¢ break ( $ ğ‘¥ ) : Br eaks out fr om the up date . Â¹â°
â€¢ ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) : Folds ğ‘“  o v er the values r eturne d by $ ğ‘¥ . W e will discuss this in Se ctionÂ 6.5 .
â€¢ ğ‘¥ ( ğ‘“1 ; â€¦ ; ğ‘“ğ‘› ) , ğ‘¥ : Calls ï¬lters. This is deï¬ne d analogously to T ableÂ 5 .
Â¹â° Note that unlike in Se ctionÂ 5 , w e do not deï¬ne the up date semantics of label $ ğ‘¥ | ğ‘“ , which could
b e use d to r esume an up date after a break . The r eason for this is that this r e quir es an additional typ e of
break  e xceptions that carries the curr ent value alongside the variable , as w ell as variants of the value
up date op erators in Se ctionÂ 4.5  that can handle unp olarise d br eaks. Be cause making up date op erators
handle unp olarise d br eaks r enders them considerably mor e comple x and w e estimate that lab el
e xpr essions ar e rar ely use d in the left-hand side of up dates any way , w e think it mor e b eneï¬cial for the
pr esentation to forgo lab el e xpr essions her e .Ther e ar e many ï¬lters ğœ‡  for which ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£  is not deï¬ne d, for e xample $ ğ‘¥ , [ ğ‘“ ] , and { } . In such
cases, w e assume that ( ğœ‡ âŠ§ ğœ ) |ğ‘
ğ‘£  r eturns an err or just like jq, b e cause these ï¬lters do not r eturn
paths to their input data. Our semantics supp ort all kinds of ï¬lters ğœ‡  that ar e supp orte d by jq,
e xcept for label $ ğ‘¥ | ğ‘” .
Example 6.4.1  (The Curious Case of Alternation) :  The semantics of ( ğ‘“ â«½ ğ‘” ) âŠ§ ğœ  can b e rather sur-
prising: For the input { " ğ‘ " â†¦ true } , the ï¬lter ( . [ " ğ‘ " ] â«½ . [ " ğ‘ " ] ) âŠ§ 1  yields { " ğ‘ " â†¦ 1 } . This is what
w e might e xp e ct, b e cause the input has an entr y for " ğ‘ " . No w let us e valuate the same ï¬lter on
the input { " ğ‘ " â†¦ false } , which yields { " ğ‘ " â†¦ false , " ğ‘ " â†¦ 1 } . Her e , while the input still has an
entr y for " ğ‘ "  like ab o v e , its b o olean value is not  true , so . [ " ğ‘ " ] âŠ§ 1  is e xe cute d. In the same spirit,
for the input { }  the ï¬lter yields { " ğ‘ " â†¦ 1 } , b e cause . [ " ğ‘ " ]  yields null  for the input, which also has
the b o olean value false , ther efor e . [ " ğ‘ " ] âŠ§ 1  is e xe cute d.
For the input { } , the ï¬lter ( false â«½ . [ " ğ‘ " ] ) âŠ§ 1  yields { " ğ‘ " â†¦ 1 } . This is r emarkable insofar as
false  is not a valid path e xpr ession b e cause it r eturns a value that do es not r efer to any part of
the original input, y et the ï¬lter do es not r eturn an err or . This is b e cause false  triggers . [ " ğ‘ " ] âŠ§ 1 ,24 FÃ¤rb er
so false  is ne v er use d as path e xpr ession. Ho w e v er , running the ï¬lter ( true â«½ . [ " ğ‘ " ] ) âŠ§ 1  do es  yield
an err or , b e cause true  triggers true âŠ§ 1 , and true  is not a valid path e xpr ession.
Finally , on the input [ ] , the ï¬lter ( . [ ] â«½ error ) âŠ§ 1  yields error ( [ ] ) . That is b e cause . [ ]  do es not
yield any value for the input, so error âŠ§ 1  is e xe cute d, which yields an err or .
6.5 FOLDING
In Se ctionÂ  5.1 , w e hav e se en ho w to e valuate folding ï¬lters of the shap e ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) , wher e ğœ™
is either reduce  or foreach . Her e , w e will deï¬ne up date semantics for these ï¬lters. These up date
op erations ar e not  supp orte d in jq 1.7; ho w e v er , w e will sho w that the y arise quite naturally fr om
pr e vious deï¬nitions.
Let us start with an e xample to understand folding on the left-hand side of an up date .
Example 6.5.1 :  Let ğ‘£ = [ [ [ 2 ] , 1 ] , 0 ]  b e our input value and ğœ‡  b e the ï¬lter ğœ™ ( 0 , 0 ) as $ ğ‘¥ ( . ; . [ $ ğ‘¥ ] ) . The
r egular e valuation of ğœ‡  with the input value as describ e d in Se ctionÂ 5  yields
ğœ‡ |{ }
ğ‘£ =
â©{â¨{â§ âŸ¨ [ 2 ] âŸ© if ğœ™ = reduce
âŸ¨ ğ‘£ , [ [ 2 ] , 1 ] , [ 2 ] âŸ© if ğœ™ = for
âŸ¨ [ [ 2 ] , 1 ] , [ 2 ] âŸ© if ğœ™ = foreach
When ğœ™ = for , the paths corr esp onding to the output ar e . , . [ 0 ] , and . [ 0 ] [ 0 ] , and when ğœ™ = reduce ,
the paths ar e just . [ 0 ] [ 0 ] . Giv en that all outputs hav e corr esp onding paths, w e can up date o v er
them. For e xample , taking . + [ 3 ]  as ï¬lter ğœ , w e should obtain the output
( ğœ‡ âŠ§ ğœ ){ }
ğ‘£=
â©{â¨{â§ âŸ¨ [ [ [ 2 , 3 ] , 1 ] , 0 ] âŸ© if ğœ™ = reduce
âŸ¨ [ [ [ 2 , 3 ] , 1 , 3 ] , 0 , 3 ] âŸ© if ğœ™ = for
âŸ¨ [ [ [ 2 , 3 ] , 1 , 3 ] , 0 ] âŸ© if ğœ™ = foreach
First, note that for folding ï¬lters, the lo w ering in T ableÂ  2  and the deï¬ning e quations in Se ctionÂ  5.1
only make use of ï¬lters for which w e hav e alr eady intr o duce d up date semantics in T ableÂ  7 . This
should not b e taken for grante d; for e xample , w e originally lo w er e d ğœ™ ğ‘“ğ‘¥ as $ ğ‘¥ ( ğ‘“ğ‘¦ ; ğ‘“ )  to
âŒŠ ğ‘“ğ‘¦ âŒ‹ as $ ğ‘¦ | ğœ™ âŒŠ ğ‘“ğ‘¥ âŒ‹ as $ ğ‘¥ ( $ ğ‘¦ ; âŒŠ ğ‘“ âŒ‹ )
instead of the mor e complicate d lo w ering found in T ableÂ 2 , namely
. as $ ğ‘¥â€²| âŒŠ ğ‘“ğ‘¦ âŒ‹ | ğœ™ âŒŠ $ ğ‘¥â€²| ğ‘“ğ‘¥ âŒ‹ as $ ğ‘¥ ( . ; âŒŠ ğ‘“ âŒ‹ ) .
While b oth lo w erings pr o duce the same output for r egular e valuation, w e cannot use the original
lo w ering for up dates, b e cause the deï¬ning e quations for ğœ™ ğ‘¥ as $ ğ‘¥ ( $ ğ‘¦ ; ğ‘“ )  w ould hav e the shap e
$ ğ‘¦ | â€¦ , which is undeï¬ne d on the left-hand side of an up date . Ho w e v er , the lo w ering in T ableÂ  2
av oids this issue by not binding the output of ğ‘“ğ‘¦  to a variable , so it can b e use d on the left-hand
side of up dates.
T o obtain an intuition ab out ho w the up date e valuation of a fold lo oks like , w e can take
ğœ™ ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) âŠ§ ğœ , substitute the left-hand side by the deï¬ning e quations in Se ctionÂ  5.1  and e x-
pand e v er ything using the pr op erties in Se ctionÂ 6.2 . This yields
reduce ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) âŠ§ ğœ = ( ( ğ‘¥0 as $ ğ‘¥ | ğ‘“ ) for ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) âŠ§ ğœ = ğœ | ( ( ğ‘¥0 as $ ğ‘¥ | ğ‘“ )
âŠ§ â€¦ âŠ§ â€¦
âŠ§ ( ( ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ ) âŠ§ ğœ | ( ( ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ )
âŠ§ ğœ ) â€¦ ) âŠ§ ğœ ) â€¦ )
and foreach  steps out of line again by not applying ğœ  initially:A formal sp e cification of the jq language 25
foreach ğ‘¥ as $ ğ‘¥ ( . ; ğ‘“ ) âŠ§ ğœ = ( ( ğ‘¥0 as $ ğ‘¥ | ğ‘“ )
âŠ§ ğœ | ( ( ğ‘¥1 as $ ğ‘¥ | ğ‘“ )
âŠ§ â€¦
âŠ§ ğœ | ( ( ğ‘¥ğ‘› as $ ğ‘¥ | ğ‘“ )
âŠ§ ğœ ) â€¦ ) .
Example 6.5.2 :  T o se e the eï¬€e ct of ab o v e e quations, let us r e consider the input value and the ï¬lters
fr om ExampleÂ 6.5.1 . Using some lib erty to write . [ 0 ]  instead of 0 as $ ğ‘¥ | . [ $ ğ‘¥ ] , w e hav e:
ğœ‡ âŠ§ ğœ =
â©{â¨{â§ . [ 0 ] âŠ§ . [ 0 ] âŠ§ ğœ if ğœ™ = reduce
ğœ | ( . [ 0 ] âŠ§ ğœ | ( . [ 0 ] âŠ§ ğœ ) ) if ğœ™ = for
. [ 0 ] âŠ§ ğœ | ( . [ 0 ] âŠ§ ğœ ) if ğœ™ = foreach
W e will no w formally deï¬ne the functions ğœ™ğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ )  use d in T ableÂ  7 . For this, w e ï¬rst intr o-
duce a function foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ , ğ‘œ ) , which r esembles its corr esp onding function in Se ctionÂ  5.1 ,
but which adds an argument for the up date ï¬lter ğœ :
foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ , ğ‘œ ) â‰”
â©{â¨{â§âˆ‘ğ‘¦ âˆˆ ğ‘œ ( ğ‘£ )( ğ‘“ âŠ§ ğœâ€² ) |ğ‘ { $ ğ‘¥ â†¦ â„ }
ğ‘¦ if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡ and ğœâ€² ( ğ‘¥ ) = foldğ‘ğ‘¥ ( ğ‘¡ , $ ğ‘¥ , ğ‘“ , ğœ , ğ‘œ )
ğœ ( ğ‘£ ) otherwise ( ğ‘™ = âŸ¨ âŸ© )
Using this function, w e can no w deï¬ne
reduceğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ ) â‰” foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ , ğ‘œ ) where ğ‘œ ( ğ‘£ ) = âŸ¨ ğ‘£ âŸ©
forğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ ) â‰” foldğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ , ğ‘œ ) where ğ‘œ ( ğ‘£ ) = ğœ ( ğ‘£ )
as w ell as
foreachğ‘
ğ‘£ ( ğ‘™ , $ ğ‘¥ , ğ‘“ , ğœ ) â‰” {( ğ‘“ âŠ§ ğœâ€² ) |ğ‘ { $ ğ‘¥ â†¦ â„ }
ğ‘£ if ğ‘™ = âŸ¨ â„ âŸ© + ğ‘¡ and ğœâ€² ( ğ‘¥ ) = forğ‘ğ‘¥ ( ğ‘¡ , $ ğ‘¥ , ğ‘“ , ğœ )
âŸ¨ ğ‘£ âŸ© otherwise
7 EQU A TIONAL REASONING SHO W CASE: OBJECT CONSTRUCTION
W e will no w sho w ho w to pr o v e pr op erties ab out HIR ï¬lters by e quational r easoning. For this,
w e use the lo w ering in Se ctionÂ  3.2  and the semantics deï¬ne d in Se ctionÂ  5 . A s an e xample , w e will
sho w a fe w pr op erties of obje ct construction.
Let us start by pr o ving a fe w help er lemmas, wher e ğ‘  and ğ‘£  always denote some arbitrar y con-
te xt and value , r esp e ctiv ely .
Lemma 7.1 :  For any HIR ï¬lters ğ‘“  and ğ‘”  and any Cartesian op erator âš¬  ( such as addition, se e T ableÂ  1 ),
w e hav e âŒŠ ğ‘“ âš¬ ğ‘” âŒ‹ |ğ‘
ğ‘£ = âˆ‘ğ‘¥ âˆˆ âŒŠ ğ‘“ âŒ‹ |ğ‘ğ‘£âˆ‘ğ‘¦ âˆˆ âŒŠ ğ‘” âŒ‹ |ğ‘ğ‘£âŸ¨ ğ‘¥ âš¬ ğ‘¦ âŸ© .
Pr o of :  The lo w ering in T ableÂ  2  yields âŒŠ ğ‘“ âš¬ ğ‘” âŒ‹ |ğ‘
ğ‘£ = ( âŒŠ ğ‘“ âŒ‹ as $ ğ‘¥â€²| âŒŠ ğ‘” âŒ‹ as $ ğ‘¦â€²| $ ğ‘¥â€²âš¬ $ ğ‘¦â€²) |ğ‘
ğ‘£ .
Using the e valuation semantics in T ableÂ  5 , w e can further e xpand this to
âˆ‘ğ‘¥ âˆˆ âŒŠ ğ‘“ âŒ‹ |ğ‘ğ‘£âˆ‘ğ‘¦ âˆˆ âŒŠ ğ‘” âŒ‹ğ‘ { $ ğ‘¥ â€² â†¦ ğ‘¥ }
ğ‘£( $ ğ‘¥â€²âš¬ $ ğ‘¦â€²) |ğ‘ { $ ğ‘¥â€²â†¦ ğ‘¥ , $ ğ‘¦â€²â†¦ ğ‘¦ }
ğ‘£ . Be cause $ ğ‘¥â€² and $ ğ‘¦â€² ar e fr esh variables, w e
kno w that the y cannot o ccur in âŒŠ ğ‘” âŒ‹ , so âŒŠ ğ‘” âŒ‹ğ‘ { $ ğ‘¥â€²â†¦ ğ‘¥ }
ğ‘£= âŒŠ ğ‘” âŒ‹ğ‘
ğ‘£. Furthermor e , by the e valuation se-
mantics, w e hav e ( $ ğ‘¥â€²âš¬ $ ğ‘¦â€²) |ğ‘ { $ ğ‘¥â€²â†¦ ğ‘¥ , $ ğ‘¦â€²â†¦ ğ‘¦ }
ğ‘£ = âŸ¨ ğ‘¥ âš¬ ğ‘¦ âŸ© . Fr om these tw o obser vations, the conclu-
sion imme diately follo ws. â–¡
Lemma 7.2 :  For any HIR ï¬lters ğ‘“  and ğ‘” , w e hav e âŒŠ { ğ‘“ : ğ‘” } âŒ‹ |ğ‘
ğ‘£ = âˆ‘ğ‘¥ âˆˆ âŒŠ ğ‘“ âŒ‹ |ğ‘ğ‘£âˆ‘ğ‘¦ âˆˆ âŒŠ ğ‘” âŒ‹ |ğ‘ğ‘£âŸ¨ { ğ‘¥ : ğ‘¦ } âŸ© .26 FÃ¤rb er
Pr o of :  Analogously to the pr o of of LemmaÂ 7.1 . â–¡
W e can no w pr o ce e d by stating a central pr op erty of obje ct construction.
The or em 7.3 :  For any ğ‘› âˆˆ â„•  with ğ‘› > 0 , w e hav e that âŒŠ { ğ‘˜1 : ğ‘£1 , â€¦ , ğ‘˜ğ‘› : ğ‘£ğ‘› } âŒ‹ |ğ‘
ğ‘£  is e quivalent to
âˆ‘
ğ‘˜1 âˆˆ âŒŠ ğ‘˜1 âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£1 âˆˆ âŒŠ ğ‘£1 âŒ‹ |ğ‘ğ‘£â€¦ âˆ‘
ğ‘˜ğ‘› âˆˆ âŒŠ ğ‘˜ğ‘› âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£ğ‘› âˆˆ âŒŠ ğ‘£ğ‘› âŒ‹ |ğ‘ğ‘£âŸ¨ âˆ‘
ğ‘–{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŸ© .
Pr o of :  W e will pr o v e by induction on ğ‘› . The base case ğ‘› = 1  dir e ctly follo ws fr om LemmaÂ  7.2 . For
the induction step , w e hav e to sho w that âŒŠ { ğ‘˜1 : ğ‘£1 , â€¦ , ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘
ğ‘£  is e quivalent to
âˆ‘
ğ‘˜1 âˆˆ âŒŠ ğ‘˜1 âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£1 âˆˆ âŒŠ ğ‘£1 âŒ‹ |ğ‘ğ‘£â€¦ âˆ‘
ğ‘˜ğ‘› + 1 âˆˆ âŒŠ ğ‘˜ğ‘› + 1 âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£ğ‘› + 1 âˆˆ âŒŠ ğ‘£ğ‘› + 1 âŒ‹ |ğ‘ğ‘£âŸ¨ âˆ‘ğ‘› + 1
ğ‘–{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŸ© .
W e start by
âŒŠ { ğ‘˜1 : ğ‘£1 , â€¦ , ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘
ğ‘£ =(lowering)
= âŒŠ âˆ‘
ğ‘–{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŒ‹ |ğ‘
ğ‘£ =
= âŒŠ âˆ‘ğ‘›
ğ‘– = 1{ ğ‘˜ğ‘– : ğ‘£ğ‘– } + { ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘
ğ‘£ =( Lemma Â  7 . 1 )
= âˆ‘
ğ‘¥ âˆˆ âŒŠ âˆ‘ğ‘›
ğ‘– = 1{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘¦ âˆˆ âŒŠ { ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘ğ‘£âŸ¨ ğ‘¥ + ğ‘¦ âŸ© .
Her e , w e obser v e that âŒŠ âˆ‘ğ‘›
ğ‘– = 1{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŒ‹ |ğ‘
ğ‘£ = âŒŠ { ğ‘˜1 : ğ‘£1 , â€¦ , ğ‘˜ğ‘› : ğ‘£ğ‘› } âŒ‹ |ğ‘
ğ‘£ , which by the induction hy-
p othesis e quals
âˆ‘
ğ‘˜1 âˆˆ âŒŠ ğ‘˜1 âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£1 âˆˆ âŒŠ ğ‘£1 âŒ‹ |ğ‘ğ‘£â€¦ âˆ‘
ğ‘˜ğ‘› âˆˆ âŒŠ ğ‘˜ğ‘› âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£ğ‘› âˆˆ âŒŠ ğ‘£ğ‘› âŒ‹ |ğ‘ğ‘£âŸ¨ âˆ‘ğ‘›
ğ‘–{ ğ‘˜ğ‘– : ğ‘£ğ‘– } âŸ© .
W e can use this to r esume the simpliï¬cation of âŒŠ { ğ‘˜1 : ğ‘£1 , â€¦ , ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘
ğ‘£  to
âˆ‘
ğ‘˜1 âˆˆ âŒŠ ğ‘˜1 âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£1 âˆˆ âŒŠ ğ‘£1 âŒ‹ |ğ‘ğ‘£â€¦ âˆ‘
ğ‘˜ğ‘› âˆˆ âŒŠ ğ‘˜ğ‘› âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘£ğ‘› âˆˆ âŒŠ ğ‘£ğ‘› âŒ‹ |ğ‘ğ‘£âˆ‘
ğ‘¦ âˆˆ âŒŠ { ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘ğ‘£âŸ¨ âˆ‘ğ‘›
ğ‘–{ ğ‘˜ğ‘– : ğ‘£ğ‘– } + ğ‘¦ âŸ©
Finally , applying LemmaÂ 7.2  to âŒŠ { ğ‘˜ğ‘› + 1 : ğ‘£ğ‘› + 1 } âŒ‹ |ğ‘
ğ‘£  pr o v es the induction step . â–¡
W e can use this the or em to simplify the e valuation of ï¬lters such as the follo wing one .
Example 7.1 :  The e valuation of { " ğ‘ " : ( 1 , 2 ) , ( " ğ‘ " , " ğ‘ " ) : 3 , " ğ‘‘ " : 4 }  yields âŸ¨ ğ‘£0 , ğ‘£1 , ğ‘£2 , ğ‘£3 âŸ© , wher e
ğ‘£0 = { " ğ‘ " â†¦ 1 , " ğ‘ " â†¦ 3 , " ğ‘‘ " â†¦ 4 } ,
ğ‘£1 = { " ğ‘ " â†¦ 1 , " ğ‘ " â†¦ 3 , " ğ‘‘ " â†¦ 4 } ,
ğ‘£2 = { " ğ‘ " â†¦ 2 , " ğ‘ " â†¦ 3 , " ğ‘‘ " â†¦ 4 } ,
ğ‘£3 = { " ğ‘ " â†¦ 2 , " ğ‘ " â†¦ 3 , " ğ‘‘ " â†¦ 4 } .
8 CONCLUSION
W e hav e sho wn formal syntax and semantics of a large subset of the jq pr ogramming language .
On the syntax side , w e ï¬rst deï¬ne d formal syntax (HIR) that closely corr esp onds to actual jq
syntax. W e then gav e a lo w ering that r e duces HIR to a simpler subset (MIR), in or der to simplifyA formal sp e cification of the jq language 27
the semantics later . W e ï¬nally sho w e d ho w a subset of actual jq syntax can b e translate d into HIR
and thus MIR.
On the semantics side , w e gav e formal semantics base d on MIR. First, w e deï¬ne d values and
basic op erations on them. Then, w e use d this to deï¬ne the semantics of jq pr ograms, by sp e cifying
the outcome of the e xe cution of a jq pr ogram. A large part of this was de dicate d to the e valuation
of up dates: In particular , w e sho w e d a ne w appr oach to e valuate up dates. This appr oach, unlike
the appr oach implemente d in jq, do es not dep end on separating path building and up dating, but
inter w eav es them. This allo ws up date op erations to cleanly handle multiple output values in cases
wher e this was not p ossible b efor e . Furthermor e , in practice , this av oids cr eating temp orar y data
to stor e paths, thus impr o ving p erformance . This appr oach is also mostly compatible with the
original jq b ehaviour , y et it is unav oidable that it div erges in some corner cases.
W e hop e that our w ork is useful in se v eral ways: For users of the jq pr ogramming language , it
pr o vides a succinct r efer ence that pr e cisely do cuments the language . Our w ork should also b en-
eï¬t implementers of to ols that pr o cess jq pr ograms, such as compilers, interpr eters, or linters. In
particular , this sp e ciï¬cation should b e suï¬ƒcient to implement the cor e of a jq compiler or inter-
pr eter . Finally , our w ork enables e quational r easoning ab out jq pr ograms. This makes it p ossible to
pr o v e corr e ctness of jq pr ograms or to implement pr o vably corr e ct optimisations in jq compilers/
interpr eters.
BIBLIOGRAPH Y
[1] D . M. Ritchie , â€œThe UNIX system: The e v olution of the UNIX time-sharing systemâ€ , A T&T Bell
Lab . T e ch. J. , v ol. 63, no . 8, pp . 1577â€“1593, 1984, doi: 10.1002/j.1538-7305.1984.tb00054.x .
[2] T . Bray , â€œThe JavaScript Obje ct Notation ( JSON) Data Inter change Formatâ€ . A ccesse d: Feb . 22,
2023. [ Online]. A vailable: https://w w w .rfc-e ditor .org/info/rfc8259
[3] Paris Data, â€œDÃ©nominations des emprises des v oies actuellesâ€ . A ccesse d: Feb . 22,
2023. [ Online]. A vailable: https://op endata.paris.fr/e xplor e/dataset/denominations-emprises-
v oies-actuelles/
[4] N. Williams and jqlang contributors, â€œjq language descriptionâ€ . A ccesse d: Feb . 20, 2023. [ On-
line]. A vailable: https://github .com/jqlang/jq/wiki/jq-Language-Description
[5] S. Dolan and jqlang contributors, â€œjq 1.7 manualâ€ . A ccesse d: Feb . 20, 2023. [ Online]. A vailable:
https://jqlang.github .io/jq/manual/v1.7/
[6] J. N. Foster , A. Pilkie wicz, and B. C. Pier ce , â€œQuotient lensesâ€ , in Pr o ce e ding of the 13th
A CM SIGPLAN international confer ence on Functional pr ogramming, ICFP 2008, Victoria, BC,
Canada, Septemb er 20-28, 2008 , J. Ho ok and P . Thiemann, Eds., A CM,  2008, pp . 383â€“396. doi:
10.1145/1411204.1411257 .
[7] J. N. Foster , M. B. Gr e enwald, J. T . Mo or e , B. C. Pier ce , and A. Schmitt, â€œCombinators for bi-di-
r e ctional tr e e transformations: a linguistic appr oach to the vie w up date pr oblemâ€ , in Pr o ce e d-
ings of the 32nd A CM SIGPLAN-SIGA CT Symp osium on Principles of Pr ogramming Languages,
POPL 2005, Long Beach, California, USA, Januar y 12-14, 2005 , J. Palsb erg and M. Abadi, Eds.,
A CM,  2005, pp . 233â€“246. doi: 10.1145/1040305.1040325 .
[8] M. Pickering, J. Gibb ons, and N. W u, â€œPr ofunctor Optics: Mo dular Data A ccessorsâ€ , A rt Sci.
Eng. Pr ogram. , v ol. 1, no . 2, p . 7, 2017, doi: 10.22152/pr ogramming-journal.org/2017/1/7 .